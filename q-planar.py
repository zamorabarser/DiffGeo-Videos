from fnmatch import translate
from this import d
from tkinter import E
from manim import *
from numpy import sqrt
from numpy import arctan2
import math


class tic2(Scene):
    def construct(self):
        t1 = Text("Signed curvature", font_size=60)
        self.play(Write(t1))
        self.wait()        


class lr(Scene):
    def construct(self):
        t1 = Tex(r"Right vs left", font_size=40, color = BLUE).shift(2.5*UP)
        g = ParametricFunction(lambda t : [-2*sqrt(2) + 2*np.sin(t), 2*np.cos(t)-1, 0], t_range = [0,6*PI + PI/4])
        g1 = ParametricFunction(lambda t : [2*sqrt(2) + 2*np.cos(t), 2*np.sin(t)-1, 0], t_range = [5*PI/4 , 15*PI /2 ])
        lin = Line([-sqrt(2), sqrt(2)-1, 0], [sqrt(2), -sqrt(2)-1,0])
        d = Dot([-2*sqrt(2),1,0], color = YELLOW)
        self.play(Write(t1))
        self.play(Create(d))
        self.play(MoveAlongPath(d, g),run_time = 4, rate_func = rate_functions.ease_in_sine)
        self.play(MoveAlongPath(d,lin), run_time = 0.75, rate_func = rate_functions.linear)
        self.play(MoveAlongPath(d,g1), run_time =4, rate_func = rate_functions.ease_out_sine)
        self.wait()
        


class theta(Scene):
    def construct(self):
        t1 = Tex(r"Angle function", font_size=40, color = BLUE).to_edge(UL).shift(0.5*RIGHT)
        l = t1.get_left()[0]
        t2 = Tex(r"Let $\gamma : [a,b] \to \mathbb{R}^2$ be smooth with $\vert \gamma ^{\prime}(t) \vert =1$ for all $t$.", font_size=40).next_to(t1, DOWN)
        t3 = Tex(r"$T : [a,b] \to \mathbb{S}^1$, ", font_size=40).next_to(t2, DOWN)
        t3.shift((t3.get_left()[0]-l )*LEFT)
        t4 = Tex(r"$\theta : [a,b] \to \mathbb{R}$", font_size=40).next_to(t3, RIGHT)
        t5 = Tex(r"$T ( t ) = (\cos(\theta (t) ), \sin (\theta (t) ) )$ for all $t \in [a,b]$", font_size=40).next_to(t3, DOWN)
        t2.shift((t2.get_left()[0]-l)*LEFT)
        t5.shift((t5.get_left()[0]-l )*LEFT)
        self.play(Write(t1), Write(t2))
        self.wait()
        self.play(Write(t3))
        self.wait()
        self.play( Write(t4), Write(t5))
        self.wait()
        names = Tex(r"$\gamma $ \hspace{1.8cm} $T$ (vector)  \hspace{1.4cm} $T$ (particle) \hspace{1.2cm} $\theta$", font_size=40).next_to(t5, DOWN).shift(0.2*DOWN)
        names.shift((names.get_center()[0] + 0.1)*LEFT)
        c = Circle(radius = 1.3, color = WHITE).shift(2.2*RIGHT + 2*DOWN)
        m = Line([5.1, -0.3, 0], [5.1, -3.7, 0])
        m1 = Line([5.0, -0.5, 0], [5.2, -0.5, 0])
        m2 = Line([5.0, -2, 0], [5.2, -2, 0])
        m3 = Line([5.0, -3.5, 0], [5.2, -3.5, 0])
        n1 = Tex(r"$ \pi $", font_size = 40).shift(5.6*RIGHT +0.5 *DOWN)
        n2 = Tex(r"$0 $", font_size = 40).shift(5.6*RIGHT +2 *DOWN)
        n3 = Tex(r"$- \pi $", font_size = 40).shift(5.6*RIGHT +3.5 *DOWN)
        self.play(Write(names), Write(c), Write(n1), Write(n2), Write(n3), Write(m), Write(m1), Write(m2), Write(m3))
        gam = ParametricFunction(lambda t : [(0.5)*t - 5  ,(1.5)* t - 3, 0], t_range = [0.1,1.3], color = BLUE)
        self.wait()
        self.play(Create(gam))
        self.wait()
        res = 2.6/sqrt(10)
        a1 = Arrow([-5,-3,0], [-5+ (0.5)*res, -3 + (1.5)*res, 0], color = PINK)
        a2 = Arrow([-1.65,-2,0], [-1.65 + (0.5)*res, -2 + (1.5)*res, 0], color = PINK)
        a3 = Dot([2.2 + res/2 ,-2 + 3*res/2,0], color = PINK)
        a4 = Dot([5.1, -2 + 1.5*(np.arctan(3))/(PI), 0], color = PINK)
        self.play(Create(a1), Create(a2), Create(a3), Create(a4))
        self.wait()
        s = ValueTracker(0)
        a1.add_updater( lambda x : x.become(Arrow( [-5 + (0.5)*s.get_value(),-3+ (1.5)*s.get_value(),0], [-4.5 + res*(0.5)*s.get_value(), -1.5+ res*(1.5)*s.get_value(), 0], color = PINK)) )
        self.play(s.animate.set_value(1), run_time = 3)
        self.wait()



class thex(Scene):
    def construct(self):
        t1 = Tex(r"Angle function", font_size=40, color = BLUE).to_edge(UL).shift(0.5*RIGHT)
        l = t1.get_left()[0]
        t2 = Tex(r"Let $\gamma : [a,b] \to \mathbb{R}^2$ be smooth with $\vert \gamma ^{\prime}(t) \vert =1$ for all $t$.", font_size=40).next_to(t1, DOWN)
        t3 = Tex(r"$T : [a,b] \to \mathbb{S}^1$, ", font_size=40).next_to(t2, DOWN)
        t3.shift((t3.get_left()[0]-l )*LEFT)
        t4 = Tex(r"$\theta : [a,b] \to \mathbb{R}$", font_size=40).next_to(t3, RIGHT)
        t5 = Tex(r"$T ( t ) = (\cos(\theta (t) ), \sin (\theta (t) ) )$ for all $t \in [a,b]$", font_size=40).next_to(t3, DOWN)
        t2.shift((t2.get_left()[0]-l)*LEFT)
        t5.shift((t5.get_left()[0]-l )*LEFT)
        self.add(t1,t2, t3, t4, t5)
        names = Tex(r"$\gamma $ \hspace{1.8cm} $T$ (vector)  \hspace{1.4cm} $T$ (particle) \hspace{1.2cm} $\theta$", font_size=40).next_to(t5, DOWN).shift(0.2*DOWN)
        names.shift((names.get_center()[0] + 0.1)*LEFT)
        c = Circle(radius = 1.3, color = WHITE).shift(2.2*RIGHT + 2*DOWN)
        m = Line([5.1, -0.3, 0], [5.1, -3.7, 0])
        m1 = Line([5.0, -0.5, 0], [5.2, -0.5, 0])
        m2 = Line([5.0, -2, 0], [5.2, -2, 0])
        m3 = Line([5.0, -3.5, 0], [5.2, -3.5, 0])
        n1 = Tex(r"$ \pi $", font_size = 40).shift(5.6*RIGHT +0.5 *DOWN)
        n2 = Tex(r"$0 $", font_size = 40).shift(5.6*RIGHT +2 *DOWN)
        n3 = Tex(r"$- \pi $", font_size = 40).shift(5.6*RIGHT +3.5 *DOWN)
        self.add(names, c, n1, n2, n3, m, m1, m2, m3)
        def cur_x(t):
            return -4.8  + 2*t/3 - (t**2)/3
        def cur_y(t):
            return -2.9 + 2*t/3 + (t**2)/3 
        def tt_x(t):
            return   1.3*(1-t)/(sqrt(2+2*t**2))
        def tt_y(t):
            return  1.3*(1+t)/(sqrt(2+2*t**2))
        gam = ParametricFunction(lambda t : [cur_x(t),cur_y(t), 0], t_range = [-1,1.5], color = BLUE)
        self.wait()
        self.play(Create(gam))
        self.wait()
        a1 = Arrow([cur_x(-1), cur_y(-1),0], [cur_x(-1) + tt_x(-1),cur_y(-1) + tt_y(-1), 0], color = PINK)
        a2 = Arrow([-1.65,-2,0], [-1.65 + tt_x(-1), -2 + tt_y(-1), 0], color = PINK) #center = [-1.65,-2,0]
        a3 = Dot([2.2 + tt_x(-1)  ,-2 + tt_y(-1) ,0], color = PINK) #center = [2.2,-2,0]
        a4 = Dot([5.1, -2 + 1.5*(arctan2( tt_y(-1),tt_x(-1)))/(PI), 0], color = PINK) #center = [5.1 , -2, 0]
        self.play(Create(a1), Create(a2), Create(a3), Create(a4))
        self.wait()
        s = ValueTracker(-1)
        a1.add_updater( lambda x : x.become(Arrow( [ cur_x(s.get_value()), cur_y(s.get_value()), 0 ], [ cur_x(s.get_value()) + tt_x(s.get_value()), cur_y(s.get_value())+tt_y(s.get_value()), 0 ], color = PINK)) )
        a2.add_updater( lambda x : x.become(Arrow( [-1.65, -2,0], [-1.65 +tt_x(s.get_value()), -2+tt_y(s.get_value()) , 0] , color = PINK )))
        a3.add_updater( lambda x : x.become(Dot( [2.2 +tt_x(s.get_value()),-2 + tt_y(s.get_value()),0],  color = PINK)))
        a4.add_updater( lambda x : x.become(Dot([5.1, -2 + 1.5*(arctan2(tt_y(s.get_value()),tt_x(s.get_value())))/(PI) , 0], color = PINK)))
        self.play(s.animate.set_value(1.4), run_time = 3)
        self.wait()




class thex2(Scene):
    def construct(self):
        t1 = Tex(r"Angle function", font_size=40, color = BLUE).to_edge(UL).shift(0.5*RIGHT)
        l = t1.get_left()[0]
        t2 = Tex(r"Let $\gamma : [a,b] \to \mathbb{R}^2$ be smooth with $\vert \gamma ^{\prime}(t) \vert =1$ for all $t$.", font_size=40).next_to(t1, DOWN)
        t3 = Tex(r"$T : [a,b] \to \mathbb{S}^1$, ", font_size=40).next_to(t2, DOWN)
        t3.shift((t3.get_left()[0]-l )*LEFT)
        t4 = Tex(r"$\theta : [a,b] \to \mathbb{R}$", font_size=40).next_to(t3, RIGHT)
        t5 = Tex(r"$T ( t ) = (\cos(\theta (t) ), \sin (\theta (t) ) )$ for all $t \in [a,b]$", font_size=40).next_to(t3, DOWN)
        t2.shift((t2.get_left()[0]-l)*LEFT)
        t5.shift((t5.get_left()[0]-l )*LEFT)
        self.add(t1,t2, t3, t4, t5)
        names = Tex(r"$\gamma $ \hspace{1.8cm} $T$ (vector)  \hspace{1.4cm} $T$ (particle) \hspace{1.2cm} $\theta$", font_size=40).next_to(t5, DOWN).shift(0.2*DOWN)
        names.shift((names.get_center()[0] + 0.1)*LEFT)
        c = Circle(radius = 1.3, color = WHITE).shift(2.2*RIGHT + 2*DOWN)
        m = Line([5.1, -0.3, 0], [5.1, -3.7, 0])
        m1 = Line([5.0, -0.5, 0], [5.2, -0.5, 0])
        m2 = Line([5.0, -2, 0], [5.2, -2, 0])
        m3 = Line([5.0, -3.5, 0], [5.2, -3.5, 0])
        n1 = Tex(r"$ \pi $", font_size = 40).shift(5.6*RIGHT +0.5 *DOWN)
        n2 = Tex(r"$0 $", font_size = 40).shift(5.6*RIGHT +2 *DOWN)
        n3 = Tex(r"$- \pi $", font_size = 40).shift(5.6*RIGHT +3.5 *DOWN)
        self.add(names, c, n1, n2, n3, m, m1, m2, m3)
        def cur_x(t):
            return -4.8  +  np.sin(t)
        def cur_y(t):
            return -2 + np.cos(t) 
        def tt_x(t):
            return  (1.3)*np.cos(t)
        def tt_y(t):
            return  -(1.3)*np.sin(t)
        gam = ParametricFunction(lambda t : [cur_x(t),cur_y(t), 0], t_range = [-PI,PI], color = BLUE)
        self.wait()
        self.play(Create(gam))
        self.wait()
        a1 = Arrow([cur_x(-PI), cur_y(-PI),0], [cur_x(-PI) + tt_x(-PI),cur_y(-PI) + tt_y(-PI), 0], color = PINK)
        a2 = Arrow([-1.65,-2,0], [-1.65 + tt_x(-PI), -2 + tt_y(-PI), 0], color = PINK) #center = [-1.65,-2,0]
        a3 = Dot([2.2 + tt_x(-PI)  ,-2 + tt_y(-PI) ,0], color = PINK) #center = [2.2,-2,0]
        a4 = Dot([5.1, -2 +1.5 , 0], color = PINK) #center = [5.1 , -2, 0]
        self.play(Create(a1), Create(a2), Create(a3), Create(a4))
        self.wait()
        s = ValueTracker(-PI)
        a1.add_updater( lambda x : x.become(Arrow( [ cur_x(s.get_value()), cur_y(s.get_value()), 0 ], [ cur_x(s.get_value()) + tt_x(s.get_value()), cur_y(s.get_value())+tt_y(s.get_value()), 0 ], color = PINK)) )
        a2.add_updater( lambda x : x.become(Arrow( [-1.65, -2,0], [-1.65 +tt_x(s.get_value()), -2+tt_y(s.get_value()) , 0] , color = PINK )))
        a3.add_updater( lambda x : x.become(Dot( [2.2 +tt_x(s.get_value()),-2 + tt_y(s.get_value()),0],  color = PINK)))
        a4.add_updater( lambda x : x.become(Dot([5.1, -2 - 3*( s.get_value())/(2*PI) , 0], color = PINK)))
        self.play(s.animate.set_value(PI), run_time = 4)
        self.wait()





class thex3(Scene):
    def construct(self):
        t1 = Tex(r"Angle function", font_size=40, color = BLUE).to_edge(UL).shift(0.5*RIGHT)
        l = t1.get_left()[0]
        t2 = Tex(r"Let $\gamma : [a,b] \to \mathbb{R}^2$ be smooth with $\vert \gamma ^{\prime}(t) \vert =1$ for all $t$.", font_size=40).next_to(t1, DOWN)
        t3 = Tex(r"$T : [a,b] \to \mathbb{S}^1$, ", font_size=40).next_to(t2, DOWN)
        t3.shift((t3.get_left()[0]-l )*LEFT)
        t4 = Tex(r"$\theta : [a,b] \to \mathbb{R}$", font_size=40).next_to(t3, RIGHT)
        t5 = Tex(r"$T ( t ) = (\cos(\theta (t) ), \sin (\theta (t) ) )$ for all $t \in [a,b]$", font_size=40).next_to(t3, DOWN)
        t2.shift((t2.get_left()[0]-l)*LEFT)
        t5.shift((t5.get_left()[0]-l )*LEFT)
        self.add(t1,t2, t3, t4, t5)
        names = Tex(r"$\gamma $ \hspace{1.8cm} $T$ (vector)  \hspace{1.4cm} $T$ (particle) \hspace{1.2cm} $\theta$", font_size=40).next_to(t5, DOWN).shift(0.2*DOWN)
        names.shift((names.get_center()[0] + 0.1)*LEFT)
        c = Circle(radius = 1.3, color = WHITE).shift(2.2*RIGHT + 2*DOWN)
        m = Line([5.1, -0.3, 0], [5.1, -3.7, 0])
        m1 = Line([5.0, -0.5, 0], [5.2, -0.5, 0])
        m2 = Line([5.0, -2, 0], [5.2, -2, 0])
        m3 = Line([5.0, -3.5, 0], [5.2, -3.5, 0])
        n1 = Tex(r"$ \pi $", font_size = 40).shift(5.6*RIGHT +0.5 *DOWN)
        n2 = Tex(r"$0 $", font_size = 40).shift(5.6*RIGHT +2 *DOWN)
        n3 = Tex(r"$- \pi $", font_size = 40).shift(5.6*RIGHT +3.5 *DOWN)
        self.add(names, c, n1, n2, n3, m, m1, m2, m3)
        def cur_x(t):
            return -5 + t/3
        def cur_y(t):
            return -2 - np.sin(t) 
        def tt_x(t):
            return  (1.3)/sqrt(1 + 9*(np.cos(t))**2)
        def tt_y(t):
            return  -(3.9)*np.cos(t)/sqrt(1 + 9*(np.cos(t))**2)
        gam = ParametricFunction(lambda t : [cur_x(t),cur_y(t), 0], t_range = [-5*PI/6,PI], color = BLUE)
        self.wait()
        self.play(Create(gam))
        self.wait()
        a1 = Arrow([cur_x(-5*PI/6), cur_y(-5*PI/6),0], [cur_x(-5*PI/6) + tt_x(-5*PI/6),cur_y(-5*PI/6) + tt_y(-5*PI/6), 0], color = PINK)
        a2 = Arrow([-1.65,-2,0], [-1.65 + tt_x(-5*PI/6), -2 + tt_y(-5*PI/6), 0], color = PINK) #center = [-1.65,-2,0]
        a3 = Dot([2.2 + tt_x(-5*PI/6)  ,-2 + tt_y(-5*PI/6) ,0], color = PINK) #center = [2.2,-2,0]
        a4 = Dot([5.1, -2 +1.5*arctan2(tt_y(-5*PI/6), tt_x(-5*PI/6))/(PI) , 0], color = PINK) #center = [5.1 , -2, 0]
        self.play(Create(a1), Create(a2), Create(a3), Create(a4))
        self.wait()
        s = ValueTracker(-5*PI/6)
        a1.add_updater( lambda x : x.become(Arrow( [ cur_x(s.get_value()), cur_y(s.get_value()), 0 ], [ cur_x(s.get_value()) + tt_x(s.get_value()), cur_y(s.get_value())+tt_y(s.get_value()), 0 ], color = PINK)) )
        a2.add_updater( lambda x : x.become(Arrow( [-1.65, -2,0], [-1.65 +tt_x(s.get_value()), -2+tt_y(s.get_value()) , 0] , color = PINK )))
        a3.add_updater( lambda x : x.become(Dot( [2.2 +tt_x(s.get_value()),-2 + tt_y(s.get_value()),0],  color = PINK)))
        a4.add_updater( lambda x : x.become(Dot([5.1, -2 + 1.5*(arctan2(tt_y(s.get_value()),tt_x(s.get_value())))/(PI) , 0], color = PINK)))
        self.play(s.animate.set_value(PI), run_time = 6)
        self.wait()




class sc(Scene):
    def construct(self):
        t1 = Tex(r"Angle function", font_size=40, color = BLUE).to_edge(UL).shift(0.5*RIGHT)
        l = t1.get_left()[0]
        t2 = Tex(r"Let $\gamma : [a,b] \to \mathbb{R}^2$ be smooth with $\vert \gamma ^{\prime}(t) \vert =1$ for all $t$.", font_size=40).next_to(t1, DOWN)
        t3 = Tex(r"$T : [a,b] \to \mathbb{S}^1$, ", font_size=40).next_to(t2, DOWN)
        t3.shift((t3.get_left()[0]-l )*LEFT)
        t4 = Tex(r"$\theta : [a,b] \to \mathbb{R}$", font_size=40).next_to(t3, RIGHT)
        t5 = Tex(r"$T ( t ) = (\cos(\theta (t) ), \sin (\theta (t) ) )$ for all $t \in [a,b]$", font_size=40).next_to(t3, DOWN)
        t2.shift((t2.get_left()[0]-l)*LEFT)
        t5.shift((t5.get_left()[0]-l )*LEFT)
        self.add(t1,t2, t3, t4, t5)
        self.wait()
        ti = Tex(r"Signed curvature", font_size=40, color = BLUE).next_to(t5, DOWN).shift(0.2*DOWN)
        ti.shift((ti.get_left()[0]-l)*LEFT)
        t6 = Tex(r"$k : [ a,b] \to \mathbb{R}$ ", font_size=40).next_to(ti, DOWN)  
        t6.shift((t6.get_left()[0]-l )*LEFT)      
        t7 = Tex(r"$k(t) : = \theta ^{\prime} (t)$ ", font_size=40).next_to(t6, DOWN)
        t7.shift((t7.get_center()[0])*LEFT)      
        b7 = SurroundingRectangle(t7, buff = .15, color = PINK)
        self.play(Write(ti), Write(t6), Write(t7), Create(b7))
        self.wait()
        t8 = Tex(r"$\kappa (t) $", r" $ = \vert T^{\prime} (t) \vert = \vert (\cos (\theta (t)),\sin (\theta (t)) )^{\prime} \vert $", font_size=40).next_to(t7, DOWN)  
        t8.shift((t8.get_center()[0] + 0.3 )*LEFT + 0.5*DOWN)      
        t9 = Tex(r" $ = \vert (-\sin (\theta (t)) \theta ^{\prime} (t),\cos (\theta (t)) \theta ^{\prime } (t) ) \vert $", font_size=40).next_to(t8, DOWN) 
        t9.shift((t9.get_left()[0]-t8[1].get_left())*LEFT)
        t90 = Tex(r" $ = \vert (-\sin (\theta (t)) ,\cos (\theta (t)) ) \vert \cdot \vert \theta ^{\prime }(t) \vert = \vert k (t) \vert $", font_size=40).next_to(t9, DOWN) 
        t90.shift((t90.get_left()[0]-t8[1].get_left())*LEFT)
        self.play(Write(t8))
        self.wait()
        self.play(Write(t9))
        self.wait()
        self.play(Write(t90))
        self.wait()
        self.play(FadeOut(t8), FadeOut(t9), FadeOut(t90))
        tre = Tex(r"$  \kappa ( t ) = \vert k (t) \vert  $", font_size=40).next_to(t7,DOWN)
        tre.shift((tre.get_center()[0] +2.5 )*LEFT + DOWN)  
        bbe = SurroundingRectangle(tre, buff = .15, color = TEAL)
        tri = Tex(r"$  \vert \Psi (\gamma  ) \vert \leq  \Phi (\gamma ) $", font_size=40).next_to(t7,DOWN)   
        tri.shift((tri.get_center()[0] -2.5 )*LEFT + DOWN)  
        bb = SurroundingRectangle(tri, buff = .15, color = TEAL)
        self.wait()
        self.play(Write(tre), Create(bbe))
        self.wait()   
        self.play(Write(tri), Create(bb))
        self.wait()     
        




class fo(Scene):
    def construct(self):
        t1 = Tex(r"Exercise", font_size=40, color = BLUE).to_edge(UL).shift(0.5*RIGHT+0.5*DOWN)
        l = t1.get_left()[0]
        t2 = Tex(r"If $\gamma : [a,b] \to \mathbb{R}^2$ is smooth regular with $\gamma (t) = (x (t), y(t))$,", font_size=40).next_to(t1, DOWN)
        t3 = Tex(r"$ k (t) = \dfrac{x^{\prime} y^{\prime \prime} - y ^{\prime} x^{\prime \prime}  }{ \left( (x^{\prime})^2 + (y^{\prime})^2 \right) ^{3/2} } $", font_size=40).next_to(t2, DOWN)
        t2.shift((t2.get_left()[0]-l )*LEFT)
        t3.shift(t3.get_center()[0]*LEFT + 0.3*DOWN)
        b3 = SurroundingRectangle(t3, buff = .15, color = ORANGE)
        self.play(Write(t1), Write(t2), Write(t3), Create(b3))
        self.wait()
        t4 = Tex(r"In particular, if  $\vert \gamma ^{\prime} (t) \vert = 1 $ for all $t$,", font_size=40).next_to(t3, DOWN)
        t4.shift((t4.get_left()[0]-l )*LEFT + 0.5*DOWN)
        t5 = Tex(r"$ k (t) = T(t) \times T^{\prime} (t) = $ det$ \left(   \begin{matrix} T_1  & T_1^{\prime} \\ T_2 & T_2^{\prime}  \end{matrix}         \right)  $", font_size=40).next_to(t4, DOWN)
        t5.shift(t5.get_center()[0]*LEFT + 0.3*DOWN)
        b5 = SurroundingRectangle(t5, buff = .15, color = ORANGE)
        self.play(Write(t4), Write(t5), Create(b5))
        self.wait()
        

class tsk(Scene):
    def construct(self):
        ti = Tex(r"Total signed curvature", font_size=40, color=BLUE).to_edge(UL)
        dtc = Tex(r"For  $\gamma : [a,b] \to \mathbb{R}^2$ smooth regular, the total signed curvature is", font_size=40).next_to(ti,DOWN)
        l = ti.get_left()[0]
        dtc.shift((dtc.get_left()[0]-l)*LEFT)
        tcf = Tex(r"$ \Psi (\gamma ) : = \int_a^b k (t) \vert \gamma ^{\prime }(t) \vert dt $.", font_size =40).next_to(dtc, DOWN)
        tcf.shift(tcf.get_center()[0]*LEFT)
        self.play(Write(ti), Write(dtc), Write(tcf))
        self.wait()
        pw = Tex(r"If  $\gamma$ is only piecewise smooth regular, there are $a = t_0 < \ldots < t_n = b$", font_size=40).next_to(tcf,DOWN)
        pw.shift((pw.get_left()[0]-l)*LEFT)
        pw2 = Tex(r"such that $\gamma \vert _{[t_{i-1}, t_i]}$ is smooth regular for each $i$.", font_size=40).next_to(pw,DOWN)
        pw2.shift((pw2.get_left()[0]-l)*LEFT)
        pw3 = Tex(r"$\Psi (\gamma )  : =  \sum_{i=1}^n  \int_{t_{i-1}}^{t_i} k (t) \vert \gamma ^{\prime } \vert  dt + \sum _{i=1}^{n-1} \angle ( \gamma^{\prime} (t_i^-), \gamma^{\prime}(t_i^+)  )$.", font_size=40).next_to(pw2,DOWN)
        pw3.shift((pw2.get_center()[0])*LEFT)
        pw33 = Tex(r"where $\angle ( \cdot , \cdot ) \in (- \pi , \pi) $ is a signed angle.", font_size=40).next_to(pw3,DOWN)
        pw33.shift((pw33.get_left()[0]-l)*LEFT)
        self.play(Write(pw), Write(pw2), Write(pw3), Write(pw33))
        self.wait()
        pw4 = Tex(r"And if $\gamma$ is closed, ", font_size=40).next_to(pw33,DOWN)
        pw4.shift((pw4.get_left()[0]-l)*LEFT)
        pw5 = Tex(r"$\Psi (\gamma )  : =  \sum_{i=1}^n  \int_{t_{i-1}}^{t_i} k (t) \vert \gamma ^{\prime } \vert  dt + \sum _{i=1}^{n-1} \angle ( \gamma^{\prime} (t_i^-), \gamma^{\prime}(t_i^+)  ) + \angle (  \gamma^{\prime} (b^{-}), \gamma ^{\prime}(a^{+}) )$.", font_size=40).next_to(pw4,DOWN)
        pw5.shift((pw5.get_center()[0])*LEFT)
        self.play(Write(pw4), Write(pw5))
        self.wait()


class closed(Scene):
    def construct(self):
        t1 = Tex(r"If $\gamma : [a,b] \to \mathbb{R}^2$ is piecewise smooth regular and closed,", font_size=40).to_edge(UL)
        l = t1.get_left()[0]
        t2 = Tex(r"$ \Psi (\gamma ) =  2 \pi m  $ for some $m \in \mathbb{Z}$", font_size=40).next_to(t1, DOWN)
        t2.shift(t2.get_center()[0]*LEFT)
        t3 = Tex(r"Furthermore, if $\gamma$ is smooth,", font_size=40).next_to(t2, DOWN)
        t3.shift((t3.get_left()[0]-l)*LEFT)
        t4 = Tex(r"$ \Psi (\gamma ) =  \theta (b) - \theta (a) $", font_size=40).next_to(t3, DOWN)
        t4.shift(t4.get_center()[0]*LEFT)
        self.play(Write(t1), Write(t2))
        self.wait()
        self.play(Write(t3), Write(t4))
        self.wait()
        names = Tex(r"$\gamma $ \hspace{2.75cm}  $\theta$ \hspace {2.75cm} $\Psi$", font_size=40).next_to(t4, DOWN).shift(0.2*DOWN)
        names.shift((names.get_center()[0] )*LEFT)
        m = Line([0, -0.3, 0], [0, -3.7, 0])
        m1 = Line([-0.1, -0.5, 0], [0.1, -0.5, 0])
        m2 = Line([-0.1, -2, 0], [0.1, -2, 0])
        m3 = Line([-0.1, -3.5, 0], [0.1, -3.5, 0])
        n1 = Tex(r"$2 \pi $", font_size = 40).shift(0.5*RIGHT +0.5 *DOWN)
        n2 = Tex(r"$0 $", font_size = 40).shift(0.5*RIGHT +2 *DOWN)
        n3 = Tex(r"$-2 \pi $", font_size = 40).shift(0.5*RIGHT +3.5 *DOWN)
        mm = Line([3.7, -0.3, 0], [3.7, -3.7, 0])
        mm1 = Line([3.6, -0.5, 0], [3.8, -0.5, 0])
        mm2 = Line([3.6, -2, 0], [3.8, -2, 0])
        mm3 = Line([3.6, -3.5, 0], [3.8, -3.5, 0])
        mn1 = Tex(r"$ 2\pi $", font_size = 40).shift(4.2*RIGHT +0.5 *DOWN)
        mn2 = Tex(r"$0 $", font_size = 40).shift(4.2*RIGHT +2 *DOWN)
        mn3 = Tex(r"$- 2\pi $", font_size = 40).shift(4.2*RIGHT +3.5 *DOWN)
        self.play(Write(names), Create(mn1), Create(mn2), Create(mn3), Create(n1), Create(n2), Create(n3), Create(m), Create(m1), Create(m2), Create(m3), Create(mm), Create(mm1),Create( mm2),  Create(mm3))
        def cur_x(t):
            return -3.7  +  1.2*np.sin(t)
        def cur_y(t):
            return -2 + 1.2* np.cos(t) 
        def tt_x(t):
            return  (1.5)*np.cos(t)
        def tt_y(t):
            return  -(1.5)*np.sin(t)
        gam = ParametricFunction(lambda t : [cur_x(t),cur_y(t), 0], t_range = [-PI,PI], color = BLUE)
        self.wait()
        self.play(Create(gam))
        self.wait()
        a1 = Arrow([cur_x(-PI), cur_y(-PI),0], [cur_x(-PI) + tt_x(-PI),cur_y(-PI) + tt_y(-PI), 0], color = PINK)
        a4 = Dot([0, -2 +0.75 , 0], color = PINK) #center = [0 , -2, 0]
        a5 = Line([3.7, -2  , 0],[3.7,-2,0], color = ORANGE) #center = [3.7 , -2, 0]
        self.play(Create(a1), Create(a5), Create(a4))
        self.wait()
        s = ValueTracker(-PI)
        a1.add_updater( lambda x : x.become(Arrow( [ cur_x(s.get_value()), cur_y(s.get_value()), 0 ], [ cur_x(s.get_value()) + tt_x(s.get_value()), cur_y(s.get_value())+tt_y(s.get_value()), 0 ], color = PINK)) )
        a4.add_updater( lambda x : x.become(Dot([0, -2 - 1.5*( s.get_value())/(2*PI) , 0], color = PINK)))
        a5.add_updater( lambda x : x.become(Line([3.7, -2, 0], [3.7, -2.75  - 1.5*(s.get_value()) /(2*PI) , 0], color = ORANGE)))
        self.play(s.animate.set_value(PI), run_time = 4)
        self.wait()


class inf(Scene):
    def construct(self):
        t1 = Tex(r"If $\gamma : [a,b] \to \mathbb{R}^2$ is piecewise smooth regular and closed,", font_size=40).to_edge(UL)
        l = t1.get_left()[0]
        t2 = Tex(r"$ \Psi (\gamma ) =  2 \pi m  $ for some $m \in \mathbb{Z}$", font_size=40).next_to(t1, DOWN)
        t2.shift(t2.get_center()[0]*LEFT)
        t3 = Tex(r"Furthermore, if $\gamma$ is smooth,", font_size=40).next_to(t2, DOWN)
        t3.shift((t3.get_left()[0]-l)*LEFT)
        t4 = Tex(r"$ \Psi (\gamma ) =  \theta (b) - \theta (a) $", font_size=40).next_to(t3, DOWN)
        t4.shift(t4.get_center()[0]*LEFT)
        names = Tex(r"$\gamma $ \hspace{2.75cm}  $\theta$ \hspace {2.75cm} $\Psi$", font_size=40).next_to(t4, DOWN).shift(0.2*DOWN)
        names.shift((names.get_center()[0] )*LEFT)
        m = Line([0, -0.3, 0], [0, -3.7, 0])
        m1 = Line([-0.1, -0.5, 0], [0.1, -0.5, 0])
        m2 = Line([-0.1, -2, 0], [0.1, -2, 0])
        m3 = Line([-0.1, -3.5, 0], [0.1, -3.5, 0])
        n1 = Tex(r"$ 2\pi $", font_size = 40).shift(0.5*RIGHT +0.5 *DOWN)
        n2 = Tex(r"$0 $", font_size = 40).shift(0.5*RIGHT +2 *DOWN)
        n3 = Tex(r"$- 2\pi $", font_size = 40).shift(0.5*RIGHT +3.5 *DOWN)
        mm = Line([3.7, -0.3, 0], [3.7, -3.7, 0])
        mm1 = Line([3.6, -0.5, 0], [3.8, -0.5, 0])
        mm2 = Line([3.6, -2, 0], [3.8, -2, 0])
        mm3 = Line([3.6, -3.5, 0], [3.8, -3.5, 0])
        mn1 = Tex(r"$ 2\pi $", font_size = 40).shift(4.2*RIGHT +0.5 *DOWN)
        mn2 = Tex(r"$0 $", font_size = 40).shift(4.2*RIGHT +2 *DOWN)
        mn3 = Tex(r"$- 2\pi $", font_size = 40).shift(4.2*RIGHT +3.5 *DOWN)
        self.add(t1,t2, t3, t4, names, n1, n2, n3, m, m1, m2, m3, mn1, mn2, mn3, mm, mm1, mm2, mm3)
        def cur_x(t):
            return -3.7  +  np.sin(t)
        def cur_y(t):
            return -2 +  np.sin(2*t) 
        def tt_x(t):
            return  np.cos(t) / sqrt(np.cos(t)**2 + 4*np.cos(2*t)**2)
        def tt_y(t):
            return  2*np.cos(2*t) / sqrt(np.cos(t)**2 + 4*np.cos(2*t)**2)
        gam = ParametricFunction(lambda t : [cur_x(t),cur_y(t), 0], t_range = [0,TAU], color = BLUE)
        self.wait()
        self.play(Create(gam))
        self.wait()
        a1 = Arrow([cur_x(0), cur_y(0),0], [cur_x(0) + 1.5*tt_x(0),cur_y(0) +1.5* tt_y(0), 0], color = PINK)
        a4 = Dot([0, -2  + 0.75*np.arctan(2)/PI , 0], color = PINK) #center = [0 , -2, 0]
        a5 = Line([3.7, -2  , 0],[3.7,-2,0], color = ORANGE) #center = [3.7 , -2, 0]
        self.play(Create(a1), Create(a5), Create(a4))
        self.wait()
        s = ValueTracker(0)
        a1.add_updater( lambda x : x.become(Arrow( [ cur_x(s.get_value()), cur_y(s.get_value()), 0 ], [ cur_x(s.get_value()) + 1.5* tt_x(s.get_value()), cur_y(s.get_value())+1.5*tt_y(s.get_value()), 0 ], color = PINK)) )
        a4.add_updater( lambda x : x.become(Dot([0, -2 + 1.5*np.arctan(tt_y(s.get_value())/tt_x(s.get_value()))/(2*PI), 0], color = PINK)))
        a5.add_updater( lambda x : x.become(Line([3.7, -2, 0], [3.7,  -2  +  1.5*(np.arctan(tt_y(s.get_value())/tt_x(s.get_value())) - np.arctan(2))/(2*PI)  , 0], color = ORANGE)))
        self.play(s.animate.set_value(PI/2), run_time = 2, rate_func = rate_functions.linear)
        a44 = Dot([0, -2.375 , 0], color = PINK)
        a55 = Line([3.7, -2  , 0],[3.7,-2 -  1.5*( PI/2  + np.arctan(2))/(2*PI)  ,0], color = ORANGE)
        self.remove(a4,a5)
        self.add(a44, a55)
        s = ValueTracker(PI/2 + 0.001)
        a44.add_updater( lambda x : x.become(Dot([0, -2 + 1.5*(np.arctan(tt_y(s.get_value())/tt_x(s.get_value())) - PI)/(2*PI), 0], color = PINK)))
        a55.add_updater( lambda x : x.become(Line([3.7, -2, 0], [3.7,  -2  +  1.5*(np.arctan(tt_y(s.get_value())/tt_x(s.get_value())) - PI - np.arctan(2))/(2*PI)  , 0], color = ORANGE)))
        self.play(s.animate.set_value(3*PI/2), run_time = 4, rate_func = rate_functions.linear)
        self.remove(a44, a55)
        s = ValueTracker(3*PI/2 + 0.001)
        self.add(a4,a5)
        self.play(s.animate.set_value(2*PI), run_time = 2, rate_func = rate_functions.linear)
        self.wait()
        


class ttt(Scene):
    def construct(self):
        ti = Tex(r"Turning tangents theorem", font_size=40, color = BLUE).to_edge(UL).shift(0.5*RIGHT)
        l = ti.get_left()[0]
        t1 = Tex(r"Let $\gamma : [a,b] \to \mathbb{R}^2$ be simple closed piecewise smooth regular. Then", font_size=40).next_to(ti, DOWN)
        t1.shift((t1.get_left()[0]-l )*LEFT)
        t2 = Tex(r"$ \Psi (\gamma ) = \pm 2 \pi$,", font_size=40).next_to(t1, DOWN)
        t2.shift((t2.get_center()[0] )*LEFT)
        t3 = Tex(r"provided $\Psi (\gamma )$ exists.", font_size=40).next_to(t2, DOWN)
        t3.shift((t3.get_left()[0]-l )*LEFT)
        self.play(Write(ti), Write(t1), Write(t2), Write(t3))
        self.wait()
        li = Tex(r"Lemma", font_size=40, color = YELLOW).next_to(t3, DOWN)
        li.shift((li.get_left()[0]-l )*LEFT)
        l1 = Tex(r"Let $p_0 p_1 \ldots p_n $ be simple closed polygon. Then", font_size=40).next_to(li, DOWN)
        l1.shift((l1.get_left()[0]-l )*LEFT)
        l2 = Tex(r"$ \sum_{i=1}^n \sphericalangle p_{i-1}p_ip_{i+1}   =  (n-2)  \pi$,", font_size=40).next_to(l1, DOWN)
        l2.shift((l2.get_center()[0] )*LEFT)
        l3 = Tex(r"where $\sphericalangle abc \in (0, 2 \pi ) $ denotes the interior angle.", font_size=40).next_to(l2, DOWN)
        l3.shift((l3.get_left()[0]-l )*LEFT)
        self.play(Write(li), Write(l1), Write(l2), Write(l3))
        self.wait()
        lem = Group(li, l1, l2, l3)
        t = ti.get_left()[1]
        self.play(FadeOut(ti), FadeOut(t1), FadeOut(t2), FadeOut(t3), lem.animate.shift((t - li.get_left()[1] )*UP))
        self.wait()
        pi = Tex(r"Proof:", font_size=40, color = YELLOW).next_to(l3, DOWN)
        pi.shift((pi.get_left()[0]-l )*LEFT)
        p1 = Tex(r"By induction on $n$ (beginning at $n=3$).", font_size=40).next_to(pi, DOWN)
        p1.shift((p1.get_left()[0]-l )*LEFT)
        p2 = Tex(r"Goal: cut the polygon in two!", font_size=40).next_to(p1, DOWN)
        p2.shift((p2.get_left()[0] -l )*LEFT)
        self.play(Write(pi), Write(p1))
        self.wait()
        a1 = Dot([2,-2,0])
        a2 = Dot([2.5, -1.2,0])
        a3 = Dot([1.35, -0.85,0])
        a4 = Dot([0.6, -2.22,0])
        a5 = Dot([1.6, -2.5,0])
        a6 = Dot([1, -3.7,0])
        a7 = Dot([2.8, -3.5,0])
        a8 = Dot([2.9, -2.3,0])
        a9 = Dot([4.15, -2.45,0])
        a10 = Dot([4.3, -1.2,0])
        a11 = Dot([3.35, -0.65,0])
        a12 = Dot([2.3, -2.8, 0])
        s1 = Line(a1.get_center(), a2.get_center(), color = YELLOW)
        s2 = Line(a2.get_center(), a3.get_center(), color = YELLOW)
        s3 = Line(a3.get_center(), a4.get_center(), color = YELLOW)
        s4 = Line(a4.get_center(), a5.get_center(), color = YELLOW)
        s5 = Line(a5.get_center(), a6.get_center(), color = YELLOW)
        s6 = Line(a6.get_center(), a7.get_center(), color = YELLOW)
        s7 = Line(a7.get_center(), a8.get_center(), color = YELLOW)
        s8 = Line(a8.get_center(), a9.get_center(), color = YELLOW)
        s9 = Line(a9.get_center(), a10.get_center(), color = YELLOW)
        s10 = Line(a10.get_center(), a11.get_center(), color = YELLOW)
        s11 = Line(a11.get_center(), a12.get_center(), color = YELLOW)
        s12 = Line(a12.get_center(), a1.get_center(), color = YELLOW)
        s0 = s12.copy()
        s00 = s12.copy()
        s01 = s7.copy()
        c1 = Line(a7.get_center(), a12.get_center(), color = RED)
        c2 = c1.copy()
        s0.append_points(s1.points)
        s0.append_points(s2.points)
        s0.append_points(s3.points)
        s0.append_points(s4.points)
        s0.append_points(s5.points)
        s0.append_points(s6.points)
        s0.append_points(s7.points)
        s0.append_points(s8.points)
        s0.append_points(s9.points)
        s0.append_points(s10.points)
        s0.append_points(s11.points)
        s0.append_points(s12.points)
        s00.append_points(s1.points)
        s00.append_points(s2.points)
        s00.append_points(s3.points)
        s00.append_points(s4.points)
        s00.append_points(s5.points)
        s00.append_points(s6.points)
        s01.append_points(s8.points)
        s01.append_points(s9.points)
        s01.append_points(s10.points)
        s01.append_points(s11.points)
        pika = Group(s0, s00, s01, c1, c2)
        pika.shift(0.7*RIGHT)
        self.play(Create(s0))
        self.wait()
        self.play(Write(p2))
        self.wait()
        self.play(Create(c1))
        self.wait()
        self.add(s00, s01, c2)
        self.remove(s0)
        self.play(s00.animate.shift(LEFT), c1.animate.shift(LEFT), s01.animate.shift(UP+0.2*RIGHT), c2.animate.shift(UP+0.2*RIGHT))
        self.wait()
        self.play(s00.animate.shift(RIGHT), c1.animate.shift(RIGHT), s01.animate.shift(DOWN-0.2*RIGHT), c2.animate.shift(DOWN-0.2*RIGHT))
        self.play(FadeOut(c1), FadeOut(c2))
        self.remove(s00, s01)
        self.add(s0)
        self.wait()
        self.play(p2.animate.shift((ti.get_left()[1]-p2.get_left()[1] - 0.5)*UP), FadeOut(li), FadeOut(l1), FadeOut(l2), FadeOut(l3), FadeOut(p1), FadeOut(pi), s0.animate.shift(3*LEFT+ UP))
        self.wait()


class pika(Scene):
    def construct(self):
        g0 = Tex(r"Goal: cut the polygon in two!", font_size=40).to_edge(UL).shift(0.5*DOWN + 0.5*RIGHT)
        l = g0.get_left()[0]
        g1 = Tex(r"First choose a point with interior angle $\theta < \pi$.", font_size = 40).next_to(g0, DOWN)
        g1.shift((g1.get_left()[0]-l)*LEFT)
        g2 = Tex(r"Case 1: The line segment between the two adjacent vertices", font_size = 40).next_to(g1, DOWN)
        g2.shift((g2.get_left()[0]-l)*LEFT)
        g3 = Tex(r"doesn't intersect the rest of the polygon.", font_size = 40).next_to(g2, DOWN)
        g3.shift((g3.get_left()[0]-l)*LEFT)
        g4 = Tex(r"Case 2: The line segment between the two adjacent vertices", font_size = 40).next_to(g1, DOWN)
        g4.shift((g4.get_left()[0]-l)*LEFT)
        g5 = Tex(r"intersects the rest of the polygon.", font_size = 40).next_to(g2, DOWN)
        g5.shift((g5.get_left()[0]-l)*LEFT)
        a1 = Dot([2,-2,0])
        a2 = Dot([2.5, -1.2,0])
        a3 = Dot([1.35, -0.85,0], color = BLUE)
        a4 = Dot([0.6, -2.22,0])
        a5 = Dot([1.6, -2.5,0])
        a6 = Dot([1, -3.7,0])
        a7 = Dot([2.8, -3.5,0])
        a8 = Dot([2.9, -2.3,0])
        a9 = Dot([4.15, -2.45,0])
        a10 = Dot([4.3, -1.2,0])
        a11 = Dot([3.35, -0.65,0])
        a12 = Dot([2.3, -2.8, 0])
        s1 = Line(a1.get_center(), a2.get_center(), color = YELLOW)
        s2 = Line(a2.get_center(), a3.get_center(), color = YELLOW)
        s22 = Line(a3.get_center(), a2.get_center())
        s3 = Line(a3.get_center(), a4.get_center(), color = YELLOW)
        s4 = Line(a4.get_center(), a5.get_center(), color = YELLOW)
        s5 = Line(a5.get_center(), a6.get_center(), color = YELLOW)
        s6 = Line(a6.get_center(), a7.get_center(), color = YELLOW)
        s7 = Line(a7.get_center(), a8.get_center(), color = YELLOW)
        s8 = Line(a8.get_center(), a9.get_center(), color = YELLOW)
        s9 = Line(a9.get_center(), a10.get_center(), color = YELLOW)
        s10 = Line(a10.get_center(), a11.get_center(), color = YELLOW)
        s11 = Line(a11.get_center(), a12.get_center(), color = YELLOW)
        s12 = Line(a12.get_center(), a1.get_center(), color = YELLOW)
        s0 = s12.copy()
        s0.append_points(s1.points)
        s0.append_points(s2.points)
        s0.append_points(s3.points)
        s0.append_points(s4.points)
        s0.append_points(s5.points)
        s0.append_points(s6.points)
        s0.append_points(s7.points)
        s0.append_points(s8.points)
        s0.append_points(s9.points)
        s0.append_points(s10.points)
        s0.append_points(s11.points)
        s00 = s2.copy()
        s00.append_points(s3.points)
        s01 = s4.copy()
        s01.append_points(s5.points)
        s01.append_points(s6.points)
        s01.append_points(s7.points)
        s01.append_points(s8.points)
        s01.append_points(s9.points)
        s01.append_points(s10.points)
        s01.append_points(s11.points)
        s01.append_points(s12.points)
        s01.append_points(s1.points)
        c1 = Line(a2.get_center(), a4.get_center(), color =RED)
        c2 = c1.copy()
        s0.shift(2.3*LEFT + UP)
        s3.shift(2.3*LEFT + UP)
        s22.shift(2.3*LEFT + UP)
        a3.shift(2.3*LEFT + UP)
        s00.shift(2.3*LEFT + UP)
        s01.shift(2.3*LEFT + UP)
        c1.shift(2.3*LEFT + UP)
        c2.shift(2.3*LEFT + UP)
        self.add(g0, s0)
        self.wait()
        th = Angle(s3, s22, radius = 0.3)
        thl = Tex(r"$\theta$", font_size = 40).next_to(th, DOWN)
        thh = Tex(r"$\theta < \pi$", font_size = 40).shift(4*RIGHT+DOWN)
        self.play(Write(g1), Create(a3), Create(th), Create(thl), Create(thh))
        self.wait()
        self.play(Write(g2), Write(g3))
        self.wait()
        self.play(FadeOut(thl), Create(c1), FadeOut(thh))
        self.add(c2, s01, s00)
        self.remove(s0)
        self.play(c1.animate.shift(LEFT), s00.animate.shift(LEFT), a3.animate.shift(LEFT), th.animate.shift(LEFT))
        self.wait()
        self.play(FadeOut(g2), FadeOut(g3), FadeOut(c1), FadeOut(c2), FadeOut(th), FadeOut(a3), FadeOut(s00), FadeOut(s01))
        self.wait()
        


class pika2(Scene):
    def construct(self):
        g0 = Tex(r"Goal: cut the polygon in two!", font_size=40).to_edge(UL).shift(0.5*DOWN + 0.5*RIGHT)
        l = g0.get_left()[0]
        g1 = Tex(r"First choose a point with interior angle $\theta < \pi$.", font_size = 40).next_to(g0, DOWN)
        g1.shift((g1.get_left()[0]-l)*LEFT)
        g4 = Tex(r"Case 2: The line segment between the two adjacent vertices", font_size = 40).next_to(g1, DOWN)
        g4.shift((g4.get_left()[0]-l)*LEFT)
        g5 = Tex(r"intersects the rest of the polygon.", font_size = 40).next_to(g4, DOWN)
        g5.shift((g5.get_left()[0]-l)*LEFT)
        g2 = Tex(r"After cutting, apply induction hypothesis to each piece.", font_size = 40).next_to(g1, DOWN)
        g2.shift((g2.get_left()[0]-l)*LEFT)
        self.add(g0, g1)
        self.wait()
        self.play(Write(g4), Write(g5))
        self.wait()
        a1 = [0*(0.7), 0.3*(0.7), 0]
        aa1 = Dot(a1, color = BLUE)
        aa11 = aa1.copy()
        a2 = [-2.8*(0.7), -3 *(0.7),0]
        a3 = [-1.9*(0.7), -4.5*(0.7), 0]
        a4 = [-1.3*(0.7), -2.2*(0.7), 0]
        aa4 = Dot(a4, color = GREEN)
        a5 = [-0.6*(0.7), -3.8*(0.7), 0]
        a6 = [-0.5*(0.7), -1.7*(0.7) , 0]
        aa6 = Dot(a6, color = GREEN)
        a7 = [ 0.4*(0.7), -1.2*(0.7) , 0 ]
        aa7 = Dot(a7, color = GREEN)
        aa77 = aa7.copy()
        a8 = [ 0.2*(0.7), -3.7 *(0.7), 0 ]
        a9 = [ 1.2*(0.7), -2.4 *(0.7), 0 ]
        aa9 = Dot(a9, color = GREEN)
        a10 = [ 2*(0.7), -4.8*(0.7) , 0 ]
        a11 = [ 2.2*(0.7), -3 *(0.7), 0 ]
        s1 = Line(a1, a2, color = YELLOW)
        s2 = Line(a2, a3, color = YELLOW)
        s3 = Line(a3, a4, color = YELLOW)
        s4 = Line(a4, a5, color = YELLOW)
        s5 = Line(a5, a6, color = YELLOW)
        s6 = Line(a6, a7, color = YELLOW)
        s7 = Line(a7, a8, color = YELLOW)
        s8 = Line(a8, a9, color = YELLOW)
        s9 = Line(a9, a10, color = YELLOW)
        s10 = Line(a10, a11, color = YELLOW)
        s11 = Line(a11, a1, color = YELLOW)
        c0 = Line(a11, a2, color = RED)
        c2 = Line(a1, a7, color = PINK)
        c3 = c2.copy()
        s0 = s1.copy()
        s0.append_points(s2.points)
        s0.append_points(s3.points)
        s0.append_points(s4.points)
        s0.append_points(s5.points)
        s0.append_points(s6.points)
        s00 = s0.copy()
        s0.append_points(s7.points)
        s0.append_points(s8.points)
        s0.append_points(s9.points)
        s0.append_points(s10.points)
        s0.append_points(s11.points)
        s01 = s7.copy()
        s01.append_points(s8.points)
        s01.append_points(s9.points)
        s01.append_points(s10.points)
        s01.append_points(s11.points)
        self.play(Create(s0))
        self.add(s01, s00)
        self.remove(s0)
        self.wait()
        self.play(Create(aa1))
        self.wait()
        self.play(Create(c0))
        self.wait()
        self.play(Create(aa4), Create(aa6), Create(aa7), Create(aa9))
        self.add(aa11, aa77)
        self.wait()
        self.play(c0.animate.shift((c0.get_center()[1] - a9[1])*DOWN))
        self.wait(0.5)
        self.play(c0.animate.shift((c0.get_center()[1] - a4[1])*DOWN))
        self.wait(0.5)
        self.play(c0.animate.shift((c0.get_center()[1] - a6[1])*DOWN))
        self.wait(0.5)
        self.play(c0.animate.shift((c0.get_center()[1] - a7[1])*DOWN))
        self.wait()
        self.play(Create(c2), FadeOut(c0))
        self.add(c3)
        self.wait()
        self.play(s01.animate.shift(RIGHT), aa9.animate.shift(RIGHT), aa77.animate.shift(RIGHT), aa11.animate.shift(RIGHT), c3.animate.shift(RIGHT), s00.animate.shift(LEFT), c2.animate.shift(LEFT), aa1.animate.shift(LEFT), aa4.animate.shift(LEFT), aa6.animate.shift(LEFT), aa7.animate.shift(LEFT))
        self.wait()

class tttp(Scene):
    def construct(self):
        ti = Tex(r"Turning tangents theorem", font_size=40, color = BLUE).to_edge(UL).shift(0.5*RIGHT)
        l = ti.get_left()[0]
        t1 = Tex(r"Let $\gamma : [a,b] \to \mathbb{R}^2$ be simple closed piecewise smooth regular. Then", font_size=40).next_to(ti, DOWN)
        t1.shift((t1.get_left()[0]-l )*LEFT)
        t2 = Tex(r"$ \Psi (\gamma ) = \pm 2 \pi$,", font_size=40).next_to(t1, DOWN)
        t2.shift((t2.get_center()[0] )*LEFT)
        t3 = Tex(r"provided $\Psi (\gamma )$ exists.", font_size=40).next_to(t2, DOWN)
        t3.shift((t3.get_left()[0]-l )*LEFT)
        self.play(Write(ti), Write(t1), Write(t2), Write(t3))
        self.wait()
        pi = Tex(r"Proof (for $\gamma$ smooth):", font_size=40, color = BLUE).to_edge(UL).next_to(t3, DOWN)
        pi.shift((pi.get_left()[0]-l )*LEFT)
        p1 = Tex(r"Choose a partition $a= t_0 < t_1 < \ldots < t_n = b$ fine enough so that:", font_size=40).next_to(pi, DOWN)
        p1.shift((p1.get_left()[0]-l )*LEFT)
        p2 = Tex(r"$\bullet $ If $p_i = \gamma (t_i ) $ for each $i$, the closed curve $p_0p_1 \ldots p_n$ is simple.", font_size=40).next_to(p1, DOWN)
        p2.shift((p2.get_left()[0] -l )*LEFT)
        p3 = Tex(r"$\bullet$ $\Phi ( \gamma \vert _{[t_{i-1}, t_i]} ) < \pi  $.", font_size=40).next_to(p2, DOWN)
        p3.shift((p3.get_left()[0]-l )*LEFT)
        self.play(Write(pi), Write(p1), Write(p2), Write(p3))
        self.wait()
        def cur_x(t):
            return 1.5+ np.cos(t)*(1 + np.cos(3*t)/5)
        def cur_y(t):
            return -2.5 + np.sin(t)*(1 + np.cos(3*t)/5)
        g = ParametricFunction(lambda t : [cur_x(t),cur_y(t), 0], t_range = [0,TAU], color = BLUE)
        a0 = [cur_x(0), cur_y(0),0]
        a1 = [cur_x(PI/4), cur_y(PI/4),0]
        a2 = [cur_x(PI/2), cur_y(PI/2),0]
        a3 = [cur_x(3*PI/4), cur_y(3*PI/4),0]
        a4 = [cur_x(PI), cur_y(PI),0]
        a5 = [cur_x(5*PI/4), cur_y(5*PI/4),0]
        a6 = [cur_x(3*PI/2), cur_y(3*PI/2),0]
        a7 = [cur_x(7*PI/4), cur_y(7*PI/4),0]
        a7b = [5*cur_x(7*PI/4)-9, 5*cur_y(7*PI/4) + 10,0]
        a0b = [5*cur_x(0)-9, 5*cur_y(0)+10,0]
        a1b = [5*cur_x(PI/4)-9, 5*cur_y(PI/4)+10,0]
        s1 = Line(a0, a1, color = YELLOW)
        s2 = Line(a1, a2, color = YELLOW)
        s3 = Line(a2, a3, color = YELLOW)
        s4 = Line(a3, a4, color = YELLOW)
        s5 = Line(a4, a5, color = YELLOW)
        s6 = Line(a5, a6, color = YELLOW)
        s7 = Line(a6, a7, color = YELLOW)
        s8 = Line(a7, a0, color = YELLOW)
        s0b = Line(a7b, a0b, color = YELLOW)
        s1b = Line(a0b, a1b, color = YELLOW)
        s0 = s1.copy()
        s0.append_points(s2.points)
        s0.append_points(s3.points)
        s0.append_points(s4.points)
        s0.append_points(s5.points)
        s0.append_points(s6.points)
        s0.append_points(s7.points)
        s0.append_points(s8.points)
        s0b = s0b.copy()
        s0b.append_points(s1b.points)        
        s00 = s8.copy()
        s00.append_points(s1.points)
        s11 = s2.copy()
        s11.append_points(s3.points)
        s11.append_points(s4.points)
        s11.append_points(s5.points)
        s11.append_points(s6.points)
        s11.append_points(s7.points)
        self.play(Create(g))
        self.wait()
        self.play(Create(s0))  
        self.wait()
        g0 = ParametricFunction(lambda t : [cur_x(t),cur_y(t), 0], t_range = [-PI/4,PI/4], color = BLUE)
        g1 = ParametricFunction(lambda t : [cur_x(t),cur_y(t), 0], t_range = [PI/4,7*PI/4], color = BLUE)
        self.add(g0,g1, s00, s11)
        self.remove(g, s0)
        g0b = ParametricFunction(lambda t : [ 5*cur_x(t) -9 ,5*cur_y(t)+10, 0], t_range = [-PI/4,PI/4], color = BLUE)
        g0b.rotate(about_point = [ 9/2 , - 5/2 , 0 ], angle = PI/2)
        s0b.rotate(about_point = [ 9/2 , - 5/2 , 0 ], angle = PI/2)
        g0b.shift(9/2*LEFT + 5/2 *UP)
        s0b.shift(9/2*LEFT + 5/2 *UP)
        self.play(FadeOut(g1), FadeOut(s11), FadeOut(ti), FadeOut(t1), FadeOut(t2), FadeOut(t3), FadeOut(pi), FadeOut(p1), FadeOut(p2), FadeOut(p3) )# g0.animate.become(g0b), s00.animate.become(s0b))
        self.play(g0.animate.rotate(about_point = [ 2.7 , - 5/2 , 0 ], angle = PI/2),  s00.animate.rotate(about_point = [ 2.7 , - 5/2 , 0 ], angle = PI/2))
        self.play(g0.animate.become(g0b), s00.animate.become(s0b))
        self.wait()





class fig(Scene):
    def construct(self):
        def cur_x(t):
            return  5* np.sin(t)*(1 + np.cos(3*t)/5)
        def cur_y(t):
            return  5*(np.cos(t)*(1 + np.cos(3*t)/5) - 6/5)
        a7b = [cur_x(7*PI/4), cur_y(7*PI/4) ,0]
        a0b = [cur_x(0), cur_y(0),0]
        a1b = [cur_x(PI/4), cur_y(PI/4),0]
        s0b = Line(a7b, a0b, color = YELLOW)
        s1b = Line(a0b, a1b, color = YELLOW)
        g0b = ParametricFunction(lambda t : [ cur_x(t)  ,cur_y(t), 0], t_range = [-PI/4,PI/4], color = BLUE)
        g = ParametricFunction(lambda t : [ cur_x(t)  ,cur_y(t), 0], t_range = [-PI/4,0], color = BLUE)
        gold = ParametricFunction(lambda t : [ cur_x(t)  ,cur_y(t), 0], t_range = [0,PI/4], color = BLUE)
        self.add(s0b, s1b, g0b)
        self.wait()
        wi1 = Tex(r"$W_i = p_{i+1}-p_i$", font_size = 40).to_edge(UL).shift(RIGHT+0.5*DOWN)
        l = wi1.get_left()
        ab = Tex(r"$\alpha _i : = \angle ( \gamma ^{\prime}(t_i), W_i) $, ", r"$\beta_i : = \angle (W_{i-1}, \gamma ^{\prime } (t_i))$, ", r"$\theta_i : = \sphericalangle p_{i-1}p_ip_{i+1} $", font_size = 40).next_to(wi1, DOWN).shift(0.3*DOWN)
        abc = Tex(r"$\alpha _i  + \beta_i + \theta_i $", r"$ = $", r"$ \pi $ ", font_size = 40).next_to(ab, DOWN).shift(0.3*DOWN)
        ab.shift((ab.get_left()-wi1.get_left())*LEFT)
        abc.shift((abc.get_left()-wi1.get_left())*LEFT)
        ulw = Line([0,0,0], [2.8,0,0], color = YELLOW).next_to(wi1, DOWN).shift(0.15*UP)
        wi1l = Tex(r"$W_{i-1}$", font_size = 30).shift(1.2*RIGHT+1.8*DOWN)
        wi2l = Tex(r"$W_i$", font_size = 30).shift(1.2*LEFT+1.8*DOWN)
        li1 = Tex(r"$\gamma (t_{i-1})$", font_size = 30).shift(3.5*RIGHT+3.3*DOWN)
        li2 = Tex(r"$\gamma (t_{i})$", font_size = 30).shift(0.5*UP)
        li3 = Tex(r"$\gamma (t_{i+1})$", font_size = 30).shift(3.5*LEFT+3.3*DOWN)
        tan1 = DashedLine( a7b, [ cur_x(7*PI/4)  -1 + 5* sqrt(2)/4  , cur_y(7*PI/4)  +1/2 + 5 *sqrt(2)/4   , 0 ])
        tan3 = DashedLine( a1b, [ cur_x(PI/4)  +1 - 5* sqrt(2)/4  , cur_y(PI/4)  +1/2 + 5 *sqrt(2)/4   , 0 ])
        tan2 = DashedLine( [-1.65,0,0] , [ 1.65,0,0 ])
        tan2n = DashedLine( [-1.65,0,0] , [ 0,0,0 ])
        tan2o = DashedLine( [0 ,0,0] , [ 1.65,0,0 ])
        ai1 = Angle( tan3 , Line(a1b, a0b) , radius = 0.5 , color = GREEN)
        ai = Angle( Line([0,0,0], [-1,0,0]) , Line(a0b, a7b), radius = 0.5 , color = GREEN)
        bi1 = Angle(  Line(a0b, a1b), Line([0,0,0], [1,0,0]) , radius = 0.5 , color = ORANGE)
        bi = Angle( Line(a7b, a0b), tan1 , radius = 0.5 , color = ORANGE)
        th = Angle( Line(a0b, a7b), Line(a0b, a1b) , radius = 0.5 , color = PINK)
        self.play(Write(li1), Write(li2), Write(li3), Write(wi1), Write(wi1l), Write(wi2l), Create(ulw))
        self.wait()
        self.play(Write(ab), Create(tan1), Create(tan2), Create(tan3))
        self.wait()
        ula = Line([0,0,0], [3.3, 0,0], color = GREEN).next_to(ab[0], DOWN).shift(0.15*UP)
        ulb = Line([0,0,0], [3.3, 0,0], color = ORANGE).next_to(ab[1], DOWN).shift(0.15*UP)
        ult = Line([0,0,0], [3.3, 0,0], color = PINK).next_to(ab[2], DOWN).shift(0.15*UP)
        self.play(Create(ai1), Create(ai), Create(ula))
        self.wait()
        self.play(Create(bi1), Create(bi), Create(ulb))
        self.wait()
        self.play(Create(th), Create(ult))
        self.wait()
        self.play(Write(abc))
        self.wait()
        self.play(ab.animate.shift((wi1.get_center()[1]-ab.get_center()[1] )*UP), FadeOut(wi1), FadeOut(ulw), ula.animate.shift((wi1.get_center()[1]-ab.get_center()[1] )*UP), ulb.animate.shift((wi1.get_center()[1]-ab.get_center()[1] )*UP), ult.animate.shift((wi1.get_center()[1]-ab.get_center()[1] )*UP), abc.animate.shift((wi1.get_center()[1]-ab.get_center()[1] )*UP))
        self.wait()
        abcd = Tex(r"$\sum_i ( $", r" $\alpha _i + \beta_i + \theta_i $", r" $ )$", r" $ =$", r" $ n \pi$", font_size = 40).next_to(ab, DOWN).shift(0.3*DOWN)
        abcd.shift( ( abcd.get_left()-l )*LEFT )
        absum = Tex(r"$\Rightarrow $ ", r" $\sum_i (\alpha _i + \beta_i) = 2 \pi$", font_size = 40).next_to(abcd, RIGHT)
        uls = Line([0,0,0], [0.5,0,0], color = YELLOW).next_to(absum[0], DOWN).shift(0.15*UP)
        self.play(Write(abcd[0]), Write(abcd[2]), abc[0].animate.become(abcd[1]), abc[1].animate.become(abcd[3]), abc[2].animate.become(abcd[4]))
        self.wait()
        self.play( Write(absum),  Write(uls))
        self.wait()
        end = Tex(r"$ \alpha _i + \beta_{i+1}  $ ", r"$= \angle (\gamma ^{\prime } (t_i), W_i) + \angle (W_i , \gamma ^{\prime} (t_{i+1})) $", font_size = 40).next_to(abcd, (1.3)* DOWN)
        end.shift(( end.get_center()[0] )*LEFT)
        end2 = Tex(r"$ = \angle (\gamma ^{\prime} (t_i), \gamma ^{\prime}(t_{i+1})) + 2 \pi m $", font_size = 40).next_to(end,  DOWN)
        end3 = Tex(r"$ = \Psi ( \gamma \vert_{[t_i, t_{i+1}]}  ) $", r" $+ 2 \pi m $", font_size = 40).next_to(end2,  DOWN)
        cest = Tex(r"$ \vert \alpha _i \vert + \vert \beta_{i+1} \vert  , \vert \Psi ( \gamma \vert_{[t_i, t_{i+1}]}  )  \vert \leq \Phi ( \gamma \vert _{[t_i, t_{i+1}]}) < \pi  $", font_size = 40).next_to(end, 1.3* DOWN)
        end2.shift(( end2.get_left()[0] - end[1].get_left()[0] )*LEFT)
        end3.shift(( end3.get_left()[0] - end[1].get_left()[0] )*LEFT)
        cest.shift(cest.get_center()[0]*LEFT)
        self.add(g, gold, tan2n, tan2o)
        self.remove(g0b, tan2)
        new = Group(g,s0b, tan1, bi, ai, tan2n)
        old = Group(gold, s1b, bi1, ai1, li1, tan2o, tan3, th, wi1l)
        self.play(new.animate.rotate(about_point = a7b, angle = - arctan2(cur_y(0)-cur_y(7*PI/4), cur_x(0)-cur_x(7*PI/4) )).shift((0.6)*UP+0.925*RIGHT), FadeOut(old), li3.animate.shift((0.6)*UP+RIGHT), li2.animate.shift(2*RIGHT+ 3.2*DOWN), wi2l.animate.shift(1.2*DOWN + 1.3*RIGHT))
        self.wait()
        self.play(Write(end))
        self.wait()
        self.play(Write(end2))
        self.wait()
        self.play(Write(end3))
        self.wait()
        self.play(FadeOut(end[1]), FadeOut(end2), end3.animate.shift((end3.get_center()[1]-end.get_center()[1])*DOWN))
        self.wait()
        self.play(Write(cest))
        self.wait()
        cross = Line([-2/3,-1/3,0], [0,0,0], color = RED).next_to(end3[1]).shift(LEFT)
        self.play(Create(cross))
        self.wait()
        self.play(FadeOut(cest))
        self.wait()
        final = Tex(r"$ \Psi (\gamma ) = \sum_i \Psi (\gamma \vert_{[t_i, t_{i+1}]} ) = \sum_i   (\alpha _ i + \beta_{i+1} )  =   2 \pi $", font_size = 40).next_to(end, 1.3* DOWN)
        final.shift(final.get_center()[0]*LEFT)
        self.play(Write(final))
        self.wait()
        


class waittest(Scene):
    def construct(self):
        a= Dot([0,0,0], color = BLUE)
        b = Dot([0,0,0], color = RED).next_to(a, 2.5*RIGHT + UP)
        self.add(a, b)
        g = Group(a,b)
        self.wait()
        self.play(g.animate.rotate(about_point = [0,-1,0], angle = PI/2).shift(3*RIGHT))
        self.wait()