from fnmatch import translate
from this import d
from tkinter import E
from manim import *
from numpy import sqrt
import math


class tic3c(Scene):
    def construct(self):
        t1 = Text("Curvature", font_size=60).shift(0.5*UP)
        t2 = Text("of curves (absolute)", font_size=60).next_to(t1, DOWN)
        self.play(Write(t1), Write(t2))
        self.wait()        


class deriv(Scene):
    def construct(self):
        ti = Tex(r"$\gamma : [a,b] \to \mathbb{R}^3$", font_size = 40).to_edge(UL)
        ti.shift(DOWN + 0.5*RIGHT)
        box = SurroundingRectangle(ti, buff = .1, color = BLUE)
        lef = ti.get_left()[0]
        ku = Tex(r"$\kappa : [a,b] \to \mathbb{R}^{+}$", font_size = 40).next_to(ti, DOWN)
        ku.shift((lef - ku.get_left()[0]) *RIGHT+0.2*DOWN)
        self.play(Write(ti),  Create (box))
        self.wait()
        self.play(Write(ku))
        self.wait()
        tip = Tex(r"$\gamma ^{\prime} : [a,b] \to \mathbb{R}^3$", font_size = 40).next_to(ti, RIGHT)
        tip.shift(6*RIGHT)
        boxp = SurroundingRectangle(tip, buff = .1, color = YELLOW)
        ga = ParametricFunction(lambda t : [t,-np.sin(t) /1.5-1,0], t_range = [-PI,PI], color = BLUE)
        self.play(Create(ga))
        self.play(Write(tip), Create(boxp))
        gap = ParametricFunction(lambda t : [t+2,-np.sin(t) /1.5 - 4* np.cos(t)/3 -1,0], t_range = [-PI,PI], color = BLUE)
        dot0 = Dot(ga.point_from_proportion(0), radius = 0)
        dot1 = Dot(gap.point_from_proportion(0), radius =0)
        deriv = Arrow(dot0.get_center() , dot1.get_center(), color= YELLOW, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        self.play(Create(dot0), Create(dot1),  Create(deriv))
        self.wait()
        para = ValueTracker(0)
        dot0.add_updater(  lambda x: x.set_x(ga.point_from_proportion(para.get_value())[0]))
        dot1.add_updater(  lambda x: x.set_x(gap.point_from_proportion(para.get_value())[0] ))
        dot0.add_updater(  lambda x: x.set_y(ga.point_from_proportion(para.get_value())[1]))
        dot1.add_updater(  lambda x: x.set_y(gap.point_from_proportion(para.get_value())[1] ))
        deriv.add_updater(  lambda x: x.become(Arrow( dot0.get_center(), dot1.get_center(), color= YELLOW, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)))
        self.play(para.animate.set_value(0.9), run_time = 10)
        self.wait()
        self.play(FadeOut(ti, ku, ga, deriv))



class tt(Scene):
    def construct(self):
        ti = Tex(r"$\gamma : [a,b] \to \mathbb{R}^3$", font_size = 40).to_edge(UL)
        ti.shift(DOWN + 0.5*RIGHT)
        lef = ti.get_left()[0]
        box = SurroundingRectangle(ti, buff = .1, color = BLUE)
        ku = Tex(r"$\kappa : [a,b] \to \mathbb{R}^{+}$", font_size = 40).next_to(ti, DOWN)
        ku.shift((lef - ku.get_left()[0]) *RIGHT+0.2*DOWN)
        self.play(Write(ti), Write(ku), Create(box))
        self.wait()
        ga = ParametricFunction(lambda t : [t,-np.sin(t) /1.5-1,0], t_range = [-PI,PI], color = BLUE)
        self.play(Create(ga))
        tip = Tex(r"$\gamma ^{\prime} : [a,b] \to \mathbb{R}^3$", font_size = 40).next_to(ti, RIGHT)
        tip.shift(6*RIGHT)
        boxp = SurroundingRectangle(tip, buff = .1, color = YELLOW)
        tipt = Tex(r"$T : [a,b] \to \mathbb{S}^2$", font_size = 40).next_to(ku, RIGHT)
        tipt.shift((tipt.get_right()[0]-tip.get_right()[0])*LEFT)
        boxpt = SurroundingRectangle(tipt, buff = .1, color = RED)
        tteq = Tex(r"$T (t) : = \dfrac{\gamma ^{\prime}(t)}{ \vert \gamma ^{\prime } (t) \vert} $", font_size = 40).next_to(tipt, DOWN)
        tteq.shift((tteq.get_right()[0]-tip.get_right()[0])*LEFT+0.05*DOWN)
        self.play(Write(tip), Create(boxp))
        self.play(Write(tipt), Create(boxpt))
        self.play(Write(tteq))
        gat = ParametricFunction(lambda t : [t+6/sqrt(9+ 2*np.cos(t)**2) ,-np.sin(t) /1.5 - 4* np.cos(t)/sqrt(9+ 2*np.cos(t)**2)-1, 0], t_range = [-PI,PI], color = BLUE)
        dot0 = Dot((1.1)*ga.point_from_proportion(0) - (0.1)*gat.point_from_proportion(0) , radius = 0)
        dot2 = Dot(gat.point_from_proportion(0), radius = 0)
        tt = Arrow(dot0.get_center() , dot2.get_center(), color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        self.play(Create(dot0), Create(dot2), Create(tt))
        self.wait()
        para = ValueTracker(0)
        dot0.add_updater(  lambda x: x.set_x((1.1)*ga.point_from_proportion(para.get_value())[0] - (0.1)*gat.point_from_proportion(para.get_value())[0] ))
        dot2.add_updater(  lambda x: x.set_x(gat.point_from_proportion(para.get_value())[0] ))
        dot0.add_updater(  lambda x: x.set_y((1.1)*ga.point_from_proportion(para.get_value())[1] - (0.1)*gat.point_from_proportion(para.get_value())[1] ))
        dot2.add_updater(  lambda x: x.set_y(gat.point_from_proportion(para.get_value())[1] ))
        tt.add_updater(  lambda x: x.become(Arrow( dot0.get_center(), dot2.get_center(), color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)))
        self.play(para.animate.set_value(0.9), run_time = 10)
        self.wait()



class kform(Scene):
    def construct(self):
        ti = Tex(r"$\gamma : [a,b] \to \mathbb{R}^3$", font_size = 40).to_edge(UL)
        ti.shift(DOWN + 0.5*RIGHT)
        lef = ti.get_left()[0]
        box = SurroundingRectangle(ti, buff = .1, color = BLUE)
        ku = Tex(r"$\kappa : [a,b] \to \mathbb{R}^{+}$", font_size = 40).next_to(ti, DOWN)
        ku.shift((lef - ku.get_left()[0]) *RIGHT+0.2*DOWN)
        self.play(Write(ti), Write(ku), Create(box))
        self.wait()
        ga = ParametricFunction(lambda t : [t,-np.sin(t) /1.5-1,0], t_range = [-PI,PI], color = BLUE)
        self.play(Create(ga))
        tip = Tex(r"$\gamma ^{\prime} : [a,b] \to \mathbb{R}^3$", font_size = 40).next_to(ti, RIGHT)
        tip.shift(6*RIGHT)
        boxp = SurroundingRectangle(tip, buff = .1, color = YELLOW)
        tipt = Tex(r"$T : [a,b] \to \mathbb{S}^2$", font_size = 40).next_to(ku, RIGHT)
        tipt.shift((tipt.get_right()[0]-tip.get_right()[0])*LEFT)
        boxpt = SurroundingRectangle(tipt, buff = .1, color = RED)
        tteq = Tex(r"$T (t) : = \dfrac{\gamma ^{\prime}(t)}{ \vert \gamma ^{\prime } (t) \vert} $", font_size = 40).next_to(tipt, DOWN)
        tteq.shift((tteq.get_right()[0]-tip.get_right()[0])*LEFT+0.05*DOWN)
        self.play(Write(tip), Create(boxp))
        self.play(Write(tipt), Create(boxpt))
        self.play(Write(tteq))
        gat = ParametricFunction(lambda t : [t+6/sqrt(9+ 2*np.cos(t)**2) ,-np.sin(t) /1.5 - 4* np.cos(t)/sqrt(9+ 2*np.cos(t)**2)-1, 0], t_range = [-PI,PI], color = BLUE)
        dot0 = Dot(ga.point_from_proportion(0.9), radius = 0)
        dot2 = Dot(gat.point_from_proportion(0.9), radius = 0)
        tt = Arrow((1.1)*dot0.get_center()  - (0.1)*dot2.get_center() , dot2.get_center(), color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        self.play(Create(dot0), Create(dot2), Create(tt))
        self.wait()
        kform = Tex(r"$\kappa (t) : = \frac{\vert T^{\prime}(t) \vert }{ \vert \gamma ^{\prime } (t) \vert } $", font_size=40)
        kform.shift((tipt.get_top()[1]-kform.get_top()[1])*UP)
        boxk = SurroundingRectangle(kform, buff = .1, color = PINK)
        self.play(Create(boxk), Write(kform))
        self.wait()




class exerk(Scene):
    def construct(self):
        ti = Tex(r"Exercise",font_size=40, color =RED ).to_edge(UL).shift(DOWN)
        b0 = Tex(r"For  $\gamma : [a,b] \to \mathbb{R}^3$ smooth regular and $\alpha = \gamma \circ \phi$ a reparametrization,", font_size=40).next_to(ti,DOWN)
        l = ti.get_left()[0]
        b0.shift((b0.get_left()[0]-l)*LEFT)
        b1 = Tex(r"$\bullet$ \hspace{0.5cm} $ \dfrac{ \vert (  \alpha ^{\prime }  / \vert \alpha ^{\prime} \vert  )^{\prime} \vert }{ \vert \alpha ^{\prime} \vert  } (t) = \dfrac{ (\gamma ^{\prime} / \vert \gamma ^{\prime } \vert ) ^{\prime} }{\vert \gamma ^{\prime } \vert  } (\phi (t)) .  $ ", font_size=40).next_to(b0,DOWN)
        b1.shift((l-b1.get_left()[0])*RIGHT+ 1.5* RIGHT)
        b2 = Tex(r"$\bullet$ $ \hspace{0.6cm} \kappa (t) = \dfrac{ \vert \gamma^{\prime \prime}(t) \times \gamma ^{\prime} (t)  \vert }{\vert \gamma ^{\prime}(t) \vert ^3} .$", font_size=40).next_to(b1,DOWN)
        b2.shift((l-b2.get_left()[0])*RIGHT+ 1.5*RIGHT)
        b3 = Tex(r"$\bullet$ \hspace{0.5cm} If $\gamma $ is a parametrization by arc length, then ", font_size=40).next_to(b2,DOWN)
        b3.shift((l-b3.get_left()[0])*RIGHT+ 1.5*RIGHT)
        b3f = Tex(r"$T(t ) = \gamma ^{\prime}(t)$ and  $  \kappa (t) = \vert \gamma^{\prime \prime } (t) \vert . $", font_size=40).next_to(b3,DOWN)
        b3f.shift((b3f.get_center()[0])*LEFT)
        self.play(Write(ti), Write(b0), Write(b1))
        self.wait()
        self.play(Write(b2))
        self.wait()
        self.play(Write(b3), Write(b3f))
        self.wait()


class totalk(Scene):
    def construct(self):
        ti = Tex(r"Total curvature", font_size=40, color=BLUE).to_edge(UL).shift(0.6*DOWN)
        dtc = Tex(r"For  $\gamma : [a,b] \to \mathbb{R}^3$ smooth regular, the total curvature is", font_size=40).next_to(ti,DOWN)
        l = ti.get_left()[0]
        dtc.shift((dtc.get_left()[0]-l)*LEFT)
        tcf = Tex(r"$ \Phi (\gamma ) : = \int_a^b \kappa (t) \vert \gamma ^{\prime }(t) \vert dt $.", font_size =40).next_to(dtc, DOWN)
        tcf.shift(tcf.get_center()[0]*LEFT)
        self.play(Write(ti), Write(dtc), Write(tcf))
        self.wait()
        pw = Tex(r"If  $\gamma$ is only piecewise smooth regular, there are $a = t_0 < \ldots < t_n = b$", font_size=40).next_to(tcf,DOWN)
        pw.shift((pw.get_left()[0]-l)*LEFT)
        pw2 = Tex(r"such that $\gamma \vert _{[t_{i-1}, t_i]}$ is smooth regular for each $i$.", font_size=40).next_to(pw,DOWN)
        pw2.shift((pw2.get_left()[0]-l)*LEFT)
        pw3 = Tex(r"$\Phi (\gamma )  : =  \sum_{i=1}^n  \int_{t_{i-1}}^{t_i} \kappa (t) \vert \gamma ^{\prime } \vert  dt + \sum _{i=1}^{n-1} \measuredangle ( \gamma^{\prime} (t_i^+), \gamma^{\prime}(t_i^-)  )$.", font_size=40).next_to(pw2,DOWN)
        pw3.shift((pw2.get_center()[0])*LEFT)
        self.play(Write(pw), Write(pw2), Write(pw3))
        self.wait()
        pw4 = Tex(r"And if $\gamma$ is closed, ", font_size=40).next_to(pw3,DOWN)
        pw4.shift((pw4.get_left()[0]-l)*LEFT)
        pw5 = Tex(r"$\Phi (\gamma )  : =  \sum_{i=1}^n  \int_{t_{i-1}}^{t_i} \kappa (t) \vert \gamma ^{\prime } \vert  dt + \sum _{i=1}^{n-1} \measuredangle ( \gamma^{\prime} (t_i^+), \gamma^{\prime}(t_i^-)  ) + \measuredangle (  \gamma^{\prime} (a^{+}), \gamma ^{\prime}(b^{-}) )$.", font_size=40).next_to(pw4,DOWN)
        pw5.shift((pw5.get_center()[0])*LEFT)
        self.play(Write(pw4), Write(pw5))
        self.wait()



class tkexer(Scene):
    def construct(self):
        exe = Tex(r"Exercise", font_size=40, color= RED).to_edge(UL).shift(DOWN)
        l = exe.get_left()[0]
        exe.shift((exe.get_left()[0]-l)*LEFT)
        es =  Tex(r"For $\gamma : [a,b] \to \mathbb{R}^3$ smooth regular, $T :[a,b] \to \mathbb{S}^2$ its tangent indicatrix,", font_size=40).next_to(exe,DOWN)
        es.shift((es.get_left()[0]-l)*LEFT)
        tcf2 = Tex(r"$ \Phi (\gamma )  = $ length$( T)$.", font_size =40).next_to(es, DOWN)
        tcf2.shift(tcf2.get_center()[0]*LEFT)
        box = SurroundingRectangle(tcf2, buff = .1, color = PINK)
        self.play(Write(exe), Write(es), Write(tcf2), Write(box))
        self.wait()
        pw = Tex(r"If  $\gamma$ is only piecewise smooth regular, the formula still holds!", font_size=40).next_to(tcf2,DOWN)
        pw.shift((pw.get_left()[0]-l)*LEFT)
        self.play(Write(pw))
        self.wait()
        names = Tex(r"$\gamma $ \hspace{2.6cm} $T$ (vector)  \hspace{2.4cm} $T$ (particle)", font_size=40).next_to(pw, DOWN)
        names.shift(names.get_center()[0]*LEFT+(0.6)*RIGHT)
        self.play(Write(names))
        gam = ParametricFunction(lambda t : [(0.5)*t -5 ,(1.5)* t - 3, 0], t_range = [0,1], color = BLUE)
        gamt = ParametricFunction(lambda t : [(0.5)*t -5 + (0.25) , (1.5)*t - 3 + (0.75), 0], t_range = [0,1], color = BLUE)
        self.play(Create(gam))
        d0 = Dot((1.5)* gam.point_from_proportion(0) -(0.5)*gamt.point_from_proportion(0)  , radius = 0 )
        d1 = Dot(gamt.point_from_proportion(0), radius =0)
        tt = Arrow(d0.get_center()  ,d1.get_center() , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        tt2 = Arrow( [0,-2,0]  , [0,-2,0]  +  d1.get_center() - d0.get_center() , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        tt3 = Dot([5,-2,0] + d1.get_center() - d0.get_center(), color = RED , radius = 0.07 )
        c = Circle(radius = 3*sqrt(10)/8, color=WHITE).shift(5*RIGHT + 2*DOWN) 
        self.play(Create(d0), Create(d1), Create(tt), Create(tt2),  Create(c), Create(tt3))
        para = ValueTracker(0)
        d0.add_updater(  lambda x: x.set_x((1.5)*gam.point_from_proportion(para.get_value())[0]-(0.5)*gamt.point_from_proportion(para.get_value())[0] ))
        d1.add_updater(  lambda x: x.set_x(gamt.point_from_proportion(para.get_value())[0] ))
        d0.add_updater(  lambda x: x.set_y((1.5)*gam.point_from_proportion(para.get_value())[1]-(0.5)*gamt.point_from_proportion(para.get_value())[1]  ))
        d1.add_updater(  lambda x: x.set_y(gamt.point_from_proportion(para.get_value())[1] ))
        tt.add_updater(  lambda x: x.become(Arrow( d0.get_center(), d1.get_center(), color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)))
        tt2.add_updater(  lambda x: x.become(Arrow( [0,-2,0] , [0,-2,0]+ d1.get_center() - d0.get_center() , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)))
        tt3.add_updater(  lambda x: x.set_x( 5 + d1.get_center()[0] -d0.get_center()[0]  ) )
        tt3.add_updater( lambda x: x.set_y(-2 + d1.get_center()[1] -d0.get_center()[1] ))
        self.play(para.animate.set_value(0.9), run_time = 3)
        


class tkexa(Scene):
    def construct(self):
        exe = Tex(r"Exercise", font_size=40, color= RED).to_edge(UL).shift(DOWN)
        l = exe.get_left()[0]
        exe.shift((exe.get_left()[0]-l)*LEFT)
        def cur_x(t):
            return -4.5  + 2*t/3 - (t**2)/3
        def cur_y(t):
            return -2.7 + 2*t/3 + (t**2)/3 - 0.4
        def tt_x(t):
            return  3*sqrt(5)*(1-t)/(10.4*sqrt(t**2 +1))
        def tt_y(t):
            return 3*sqrt(5)*(1+t)/(10.4*sqrt(t**2 +1))
        es =  Tex(r"For $\gamma : [a,b] \to \mathbb{R}^3$ smooth regular, $T :[a,b] \to \mathbb{S}^2$ its tangent indicatrix,", font_size=40).next_to(exe,DOWN)
        es.shift((es.get_left()[0]-l)*LEFT)
        tcf2 = Tex(r"$ \Phi (\gamma )  = $ length$( T)$.", font_size =40).next_to(es, DOWN)
        tcf2.shift(tcf2.get_center()[0]*LEFT)
        pw = Tex(r"If  $\gamma$ is only piecewise smooth regular, the formula still holds!", font_size=40).next_to(tcf2,DOWN)
        pw.shift((pw.get_left()[0]-l)*LEFT)
        names = Tex(r"$\gamma $ \hspace{2.6cm} $T$ (vector)  \hspace{2.4cm} $T$ (particle)", font_size=40).next_to(pw, DOWN)
        names.shift(names.get_center()[0]*LEFT+(0.6)*RIGHT)
        box = SurroundingRectangle(tcf2, buff = .1, color = PINK)
        self.play(Write(exe), Write(es), Write(tcf2), Write(pw), Write(names), Create(box))
        gam = ParametricFunction(lambda t : [ cur_x(t)  ,  cur_y(t)  , 0 ], t_range = [-1,1.5], color = BLUE)
        self.play(Create(gam))
        d0 = Dot([ cur_x(-1) - (0.3)*tt_x(-1), cur_y(-1)- (0.3)*tt_y(-1) ,0 ] , radius = 0)
        d1 = Dot( [cur_x(-1) + tt_x(-1),   cur_y(-1) + tt_y(-1) , 0], radius =0)
        tt = Arrow(d0.get_center()  ,d1.get_center() , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        tt2 = Arrow( [0,-2,0]  , [0,-2,0]  +  d1.get_center() - d0.get_center() , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        tt3 = Dot([5,-2,0] + d1.get_center() - d0.get_center(), color = RED , radius = 0.1 )
        c = Circle(radius = 3*sqrt(10)/8, color=WHITE).shift(5*RIGHT + 2*DOWN) 
        self.play(Create(d0), Create(d1), Create(tt), Create(tt2),  Create(c), Create(tt3))
        path = VMobject()
        path.set_points_as_corners([tt3.get_center(), tt3.get_center()])
        def update_path(path):
            previous_path = path.copy()
            previous_path.add_points_as_corners([tt3.get_center()])
            previous_path.set_color(PINK)
            path.become(previous_path)
        path.add_updater(update_path)
        self.add(path)
        para = ValueTracker(-1)
        d0.add_updater(  lambda x: x.set_x( cur_x(para.get_value()) - (0.3)*tt_x(para.get_value())  ))
        d1.add_updater(  lambda x: x.set_x( cur_x(para.get_value()) + tt_x(para.get_value()) ))
        d0.add_updater(  lambda x: x.set_y( cur_y(para.get_value()) - (0.3)*tt_y(para.get_value()) ))
        d1.add_updater(  lambda x: x.set_y( cur_y(para.get_value()) + tt_y(para.get_value()) ))
        tt.add_updater(  lambda x: x.become(Arrow( d0.get_center(), d1.get_center(), color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)))
        tt2.add_updater(  lambda x: x.become(Arrow( [0,-2,0] , [0,-2,0]+ d1.get_center() - d0.get_center() , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)))
        tt3.add_updater(  lambda x: x.set_x( 5 + d1.get_center()[0] -d0.get_center()[0]  ) )
        tt3.add_updater( lambda x: x.set_y(-2 + d1.get_center()[1] -d0.get_center()[1] ))
        self.play(para.animate.set_value(1.4), run_time = 3)
        
class sqtest(Scene):
    def construct(self):
        gam = ParametricFunction(lambda t : [ -4.5  + 2*t/3 - (t**2)/3  ,  -2.7 + 2*t/3 + (t**2)/3  , 0 ], t_range = [-1,1.5], color = BLUE)
        gam2 = ParametricFunction(lambda t : [ t**2  , 0  , 0 ], t_range = [0,2], color = BLUE)
        gamt = ParametricFunction(lambda t : [ -4.5  + 2*t/3 - (t**2)/3  + (1-t)/sqrt(t**2 +1) ,  -2.7 + 2*t/3 + (t**2)/3 + (1+t)/sqrt(t**2 +1)  , 0], t_range = [-1,1.5], color = GREEN)
        self.play(Create(gam), Create(gamt), Create(gam2))
        gamtt = ParametricFunction(lambda t :[  (1-t)/sqrt(t**2 +1) , (1+t)/sqrt(t**2 +1) , 0  ] , t_range = [-1,1.5], color = BLUE)
        self.play(Create(gamtt))
        self.wait()
        d0 = Dot(gam.point_from_proportion(0), radius =0 ) 
        d1 = Dot(gamt.point_from_proportion(0), radius =0)
        d2 = Dot(gam2.point_from_proportion(0.5), radius =0.1 , color=RED)
        self.add(d0,d1, d2)
        tt = Arrow([0,0,0], d1.get_center()-d0.get_center(),color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        self.add(tt)
        self.wait()
        para = ValueTracker(0)
        d0.add_updater(  lambda x: x.become(Dot( gam.point_from_proportion(para.get_value()), radius =0) ))
        d1.add_updater(  lambda x: x.become(Dot( gamt.point_from_proportion(para.get_value()), radius =0) ))
        tt.add_updater(  lambda x: x.become(Arrow( [0,0,0],  d1.get_center() - d0.get_center(), color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)))
        self.play(para.animate.set_value(0.9), run_time = 3)
        

class ptest(Scene):
    def construct(self):
        gam = ParametricFunction(lambda t : [ -4.5  + 2*t/3 - (t**2)/3  ,  -2.7 + 2*t/3 + (t**2)/3  , 0 ], t_range = [-1,1.5], color = BLUE)
        self.play(Create(gam))
        d1 = Dot( gam )
        self.play(Create(d1))
        self.wait()

class tkex2(Scene):
    def construct(self):
        exe = Tex(r"Exercise", font_size=40, color= RED).to_edge(UL).shift(DOWN)
        l = exe.get_left()[0]
        exe.shift((exe.get_left()[0]-l)*LEFT)
        es =  Tex(r"For $\gamma : [a,b] \to \mathbb{R}^3$ smooth regular, $T :[a,b] \to \mathbb{S}^2$ its tangent indicatrix,", font_size=40).next_to(exe,DOWN)
        es.shift((es.get_left()[0]-l)*LEFT)
        tcf2 = Tex(r"$ \Phi (\gamma )  = $ length$( T)$.", font_size =40).next_to(es, DOWN)
        tcf2.shift(tcf2.get_center()[0]*LEFT)
        pw = Tex(r"If  $\gamma$ is only piecewise smooth regular, the formula still holds!", font_size=40).next_to(tcf2,DOWN)
        pw.shift((pw.get_left()[0]-l)*LEFT)
        names = Tex(r"$\gamma $ \hspace{2.6cm} $T$ (vector)  \hspace{2.4cm} $T$ (particle)", font_size=40).next_to(pw, DOWN)
        names.shift(names.get_center()[0]*LEFT+(0.6)*RIGHT)
        box = SurroundingRectangle(tcf2, buff = .1, color = PINK)
        self.play(Write(exe), Write(es), Write(tcf2), Write(pw), Write(names), Create(box))
        gam = ParametricFunction(lambda t : [ -5 + np.sin(t) ,  -2  + np.cos(t) , 0 ], t_range = [0,TAU], color = BLUE)
        gamt = ParametricFunction(lambda t : [ -5 + np.sin(t) + 3*sqrt(10)*np.cos(t)/(10.4) ,  -2  + np.cos(t) - 3*sqrt(10)*np.sin(t)/(10.4)  , 0], t_range = [0,TAU], color = BLUE)
        self.play(Create(gam))
        d0 = Dot((1.3)* gam.point_from_proportion(0) -(0.3)*gamt.point_from_proportion(0)  , radius = 0 )
        d1 = Dot(gamt.point_from_proportion(0), radius =0)
        tt = Arrow(d0.get_center()  ,d1.get_center() , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        tt2 = Arrow( [0,-2,0]  , [0,-2,0]  +  d1.get_center() - d0.get_center() , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        tt3 = Dot([5,-2,0] + d1.get_center() - d0.get_center(), color = RED , radius = 0.1 )
        c = Circle(radius = 3*sqrt(10)/8, color=WHITE).shift(5*RIGHT + 2*DOWN) 
        self.play(Create(d0), Create(d1), Create(tt), Create(tt2),  Create(c), Create(tt3))
        path = VMobject()
        path.set_points_as_corners([tt3.get_center(), tt3.get_center()])
        def update_path(path):
            previous_path = path.copy()
            previous_path.add_points_as_corners([tt3.get_center()])
            previous_path.set_color(PINK)
            path.become(previous_path)
        path.add_updater(update_path)
        self.add(path)
        para = ValueTracker(0)
        d0.add_updater(  lambda x: x.set_x((1.3)*gam.point_from_proportion(para.get_value())[0]-(0.3)*gamt.point_from_proportion(para.get_value())[0] ))
        d1.add_updater(  lambda x: x.set_x(gamt.point_from_proportion(para.get_value())[0] ))
        d0.add_updater(  lambda x: x.set_y((1.3)*gam.point_from_proportion(para.get_value())[1]-(0.3)*gamt.point_from_proportion(para.get_value())[1]  ))
        d1.add_updater(  lambda x: x.set_y(gamt.point_from_proportion(para.get_value())[1] ))
        tt.add_updater(  lambda x: x.become(Arrow( d0.get_center(), d1.get_center(), color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)))
        tt2.add_updater(  lambda x: x.become(Arrow( [0,-2,0] , [0,-2,0]+ d1.get_center() - d0.get_center() , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)))
        tt3.add_updater(  lambda x: x.set_x( 5 + d1.get_center()[0] -d0.get_center()[0]  ) )
        tt3.add_updater( lambda x: x.set_y(-2 + d1.get_center()[1] -d0.get_center()[1] ))
        self.play(para.animate.set_value(1), run_time = 3)
        



class tkex3(Scene):
    def construct(self):
        exe = Tex(r"Exercise", font_size=40, color= RED).to_edge(UL).shift(DOWN)
        l = exe.get_left()[0]
        exe.shift((exe.get_left()[0]-l)*LEFT)
        es =  Tex(r"For $\gamma : [a,b] \to \mathbb{R}^3$ smooth regular, $T :[a,b] \to \mathbb{S}^2$ its tangent indicatrix,", font_size=40).next_to(exe,DOWN)
        es.shift((es.get_left()[0]-l)*LEFT)
        tcf2 = Tex(r"$ \Phi (\gamma )  = $ length$( T)$.", font_size =40).next_to(es, DOWN)
        tcf2.shift(tcf2.get_center()[0]*LEFT)
        pw = Tex(r"If  $\gamma$ is only piecewise smooth regular, the formula still holds!", font_size=40).next_to(tcf2,DOWN)
        pw.shift((pw.get_left()[0]-l)*LEFT)
        names = Tex(r"$\gamma $ \hspace{2.6cm} $T$ (vector)  \hspace{2.4cm} $T$ (particle)", font_size=40).next_to(pw, DOWN)
        names.shift(names.get_center()[0]*LEFT+(0.6)*RIGHT)
        box = SurroundingRectangle(tcf2, buff = .1, color = PINK)
        c = Circle(radius = 3*sqrt(10)/8, color=WHITE).shift(5*RIGHT + 2*DOWN) 
        self.play(Write(exe), Write(es), Write(tcf2), Write(pw), Write(names), Create(box), Create(c))
        gam = Line([-5 - sqrt(3)/2 , -2.5, 0], [ -5,-3,0 ], color = BLUE)
        gam.append_points(Line([-5,-3,0], [-5 + sqrt(3)/2, -2.5 , 0 ]).points).append_points(Line( [-5 + sqrt(3)/2, -2.5 , 0 ],[ -5 + sqrt(3)/2, -1.5 , 0 ]).points)
        gam.append_points(Line( [ -5 + sqrt(3)/2, -1.5 , 0 ], [ -5,-1,0  ]).points).append_points(Line( [ -5,-1,0  ], [-5 - sqrt(3)/2 , -1.5, 0]  ).points)
        gam.shift(0.3*RIGHT)
        self.play(Create(gam))
        p = Dot([-5 - sqrt(3)/2 , -2.5, 0], radius = 0 )
        q = Dot(p.get_center() + [ 3 * sqrt(30) / 16 ,- 3 *sqrt(10)/16, 0 ]  , radius = 0 )
        p.shift(0.3*RIGHT)
        q.shift(0.3*RIGHT)
        c1 = Circle(radius = 3*sqrt(10)/8, color=WHITE).shift( (4.7)*LEFT + 3*DOWN)
        ar = Arrow(p,q , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        ar2 = Arrow([0,-2,0], [0,-2,0] + q.get_center() - p.get_center(), color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        tt = Dot( [5,-2,0] + q.get_center() - p.get_center(), color = RED , radius = 0.1)
        self.play(Create(ar), Create(ar2), Create(tt))
        path = VMobject()
        path.set_points_as_corners([tt.get_center(), tt.get_center()])
        def update_path(path):
            previous_path = path.copy()
            previous_path.add_points_as_corners([tt.get_center()])
            previous_path.set_color(PINK)
            path.become(previous_path)
        path.add_updater(update_path)
        self.add(path)
        ar.add_updater( lambda x: x.become(  Arrow(p,q , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)   ) )
        ar2.add_updater( lambda x: x.become(   Arrow([0,-2,0], [0,-2,0] + q.get_center() - p.get_center(), color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)))
        tt.add_updater( lambda x: x.become( Dot( [5,-2,0] + q.get_center() - p.get_center(), color = RED , radius = 0.1) ) )
        self.play(p.animate.shift((sqrt(3)/2)*RIGHT + 0.5*DOWN), q.animate.shift((sqrt(3)/2)*RIGHT + 0.5*DOWN))
        self.play(Rotating(q, radians= PI / 3, about_point= [ -4.7, -3, 0 ] , run_time =1))
        self.play(p.animate.shift((sqrt(3)/2)*RIGHT + 0.5*UP), q.animate.shift((sqrt(3)/2)*RIGHT + 0.5*UP))
        self.play(Rotating(q, radians= PI / 3, about_point= [ -4.7 + sqrt(3)/2, -2.5, 0 ] , run_time =1))
        self.play(p.animate.shift(UP), q.animate.shift(UP))
        self.play(Rotating(q, radians= PI / 3, about_point= [ -4.7 + sqrt(3)/2, -1.5, 0 ] , run_time =1))
        self.play(p.animate.shift( (sqrt(3)/2)*LEFT + (0.5)*UP), q.animate.shift((sqrt(3)/2)*LEFT + (0.5)*UP))
        self.play(Rotating(q, radians= PI / 3, about_point= [ -4.7 , -1 , 0 ] , run_time =1))
        self.play(p.animate.shift( (sqrt(3)/2)*LEFT + (0.5)*DOWN), q.animate.shift((sqrt(3)/2)*LEFT + (0.5)*DOWN))
        self.wait()
        lin = Line( [ -5 - sqrt(3)/2 + 0.3, -1.5 , 0 ],  [ -5 - sqrt(3)/2 + 0.3, -2.5 , 0 ] , color = BLUE )
        self.play(Create(lin))
        self.wait()
        self.play(Rotating(q, radians= PI / 3, about_point= [ -4.7 - sqrt(3)/2, -1.5, 0 ] , run_time =1))
        self.play(p.animate.shift(DOWN), q.animate.shift(DOWN))
        self.play(Rotating(q, radians= PI / 3, about_point= [ -4.7 - sqrt(3)/2, -2.5, 0 ] , run_time =1))
        self.wait()


class artest(Scene):
    def construct(self):
        d0 = Dot([0,0,0], color=RED)
        d1 = Dot([2,0,0], color = BLUE)
        d00 = Dot([0,1,0], color=RED)
        d11 = Dot([1,1,0], color = BLUE)
        x = Dot([-0.6 , 0 ,0 ], color = GREEN)
        y = Dot([-0.3,1,0], color = GREEN)
        z = Dot([-0.3,0,0], color = PINK)
        a1 = Arrow(z,d1 , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        a2 = Arrow(y,d11 , color= RED, stroke_width=6, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.15)
        self.play(Create(d0),Create(d1),Create(d00),Create(d11), Create(z))
        self.wait()
        self.play(Create(a1), Create(a2))
        self.wait()




class tin(Scene):
    def construct(self):
        exe = Tex(r"Wire in a tin", font_size=40, color= RED).to_edge(UL).shift(DOWN)
        l = exe.get_left()[0]
        sta = Tex(r"Show that if $\gamma : [a,b] \to \mathbb{R}^3$ is closed and $\vert \gamma (t) \vert \leq 1$ for all $t$, then", font_size = 40).next_to(exe, DOWN)
        sta.shift((sta.get_left()[0]-l)*LEFT)
        phi = Tex(r"$\Phi ( \gamma) \geq $ length$(\gamma).$", font_size = 40).next_to(sta, DOWN)
        phi.shift(phi.get_center()[0]*LEFT)
        box = SurroundingRectangle(phi, buff = .1, color = PINK)
        self.play(Write(exe), Write(sta), Write(phi), Create(box))
        c = Circle(radius = 1.6, color=WHITE).shift(1.9*DOWN)
        gam = Line([0,-0.6,0], [-1.2, -1.5, 0], color = BLUE).append_points(Line([-1.2,-1.5,0], [-0.7,-2.7,0], color=BLUE).points)
        gam.append_points(Line([-0.7,-2.7,0], [0.2,-2.2,0], color=BLUE).points).append_points(Line([0.2,-2.2,0], [-0.5,-3.1,0], color =BLUE).points)
        gam.append_points(Line([-0.5,-3.1,0],[ 0.7,-2.7, 0] , color=BLUE).points).append_points(Line([ 0.7,-2.7, 0], [1.1,-1.3,0] , color=BLUE).points)
        gam.append_points(Line([1.1,-1.3,0], [0,-0.6,0] , color=BLUE).points)
        self.play(Create(c), Create(gam))
        self.wait()
        self.play(FadeOut(exe), FadeOut(sta), FadeOut(phi), FadeOut(box))
        self.wait()



class tin2(Scene):
    def construct(self):
        c = Circle(radius = 1.6, color=WHITE).shift(1.9*DOWN)
        gam = Line([0,-0.6,0], [-1.2, -1.5, 0], color = BLUE).append_points(Line([-1.2,-1.5,0], [-0.7,-2.7,0], color=BLUE).points)
        gam.append_points(Line([-0.7,-2.7,0], [0.5,-2,0], color=BLUE).points).append_points(Line([0.5,-2,0], [-0.5,-3.1,0], color =BLUE).points)
        gam.append_points(Line([-0.5,-3.1,0],[ 0.7,-2.7, 0] , color=BLUE).points).append_points(Line([ 0.7,-2.7, 0], [1.1,-1.3,0] , color=BLUE).points)
        gam.append_points(Line([1.1,-1.3,0], [0,-0.6,0] , color=BLUE).points)
        self.play(Create(c), Create(gam))
        self.wait()
        p1 = Polygon([0,-0.6,0], [-1.2,-1.5,0], [0,-1.9,0], fill_color=RED ,color= RED, stroke_width =1   ,  fill_opacity = 0.3)
        p2 = Polygon([-1.2, -1.5,0], [-0.7,-2.7,0], [0,-1.9,0], fill_color=ORANGE ,color= ORANGE, stroke_width =1   ,  fill_opacity = 0.3)
        p3 = Polygon([-0.7,-2.7,0], [0.5,-2,0], [0,-1.9,0], fill_color=YELLOW ,color= YELLOW, stroke_width =1   ,  fill_opacity = 0.3)
        p4 = Polygon([0.5,-2,0], [-0.5,-3.1,0], [0,-1.9,0], fill_color=GREEN ,color= GREEN, stroke_width =1   ,  fill_opacity = 0.3)
        p5 = Polygon([-0.5,-3.1,0], [0.7,-2.7,0], [0,-1.9,0], fill_color=BLUE ,color= BLUE, stroke_width =1   ,  fill_opacity = 0.3)
        p6 = Polygon([0.7,-2.7,0], [1.1,-1.3,0], [0,-1.9,0], fill_color=PURPLE_E ,color= PURPLE_E, stroke_width =1   ,  fill_opacity = 0.3)
        p7 = Polygon( [1.1,-1.3,0] , [0,-0.6,0], [0,-1.9,0], fill_color=PINK ,color= PINK, stroke_width =1   ,  fill_opacity = 0.3)
        self.play(Create(p1))
        self.play(Create(p2))
        self.play(Create(p3))
        self.play(Create(p4))
        self.play(Create(p5))
        self.play(Create(p6))
        self.play(Create(p7))
        pp1 = p1.copy()
        pp2 = p2.copy()
        pp3 = p3.copy()
        pp4 = p4.copy()
        pp5 = p5.copy()
        pp6 = p6.copy()
        pp7 = p7.copy()
        self.add(pp1)
        self.play(Rotating(pp1, radians= PI  - math.atan(3/4) , about_point= [ -1.2 ,-1.5 , 0 ] , run_time=1 ))
        self.play(pp1.animate.shift(2.15*LEFT + 2*UP))
        self.add(pp2)
        self.play(Rotating(pp2, radians= math.atan(12/5) , about_point= [ -0.7 ,-2.7 , 0 ], run_time=1 ))
        self.play(pp2.animate.shift(1.35*LEFT + 3.2*UP))
        self.add(pp3)
        self.play(Rotating(pp3, radians=  - math.atan(7/12) , about_point= [ 0.5 ,-2 , 0 ], run_time=1 ))
        self.play(pp3.animate.shift((2.55-sqrt(1.93))*LEFT + 2.5*UP))
        self.add(pp4)
        self.play(pp4.animate.become(Polygon([-1.5,-2,0], [-0.5,-3.1,0], [-1,-1.9,0], fill_color=GREEN ,color= GREEN, stroke_width =1   ,  fill_opacity = 0.3)    ))
        self.play(Rotating(pp4, radians=  math.atan(1.1) , about_point= [ -0.5 ,-3.1 , 0 ], run_time=1 ))
        self.play(pp4.animate.shift(( 1.55-sqrt(1.93)- sqrt(2.21))*LEFT + 3.6*UP))
        self.add(pp5)
        self.play(Rotating(pp5, radians= - math.atan(1/3) , about_point= [ 0.7 ,-2.7 , 0 ], run_time=1 ))
        self.play(pp5.animate.shift(( 2.75-sqrt(1.93)- sqrt(2.21)-sqrt(1.6) )*LEFT + 3.2*UP))
        self.add(pp6)
        self.play(Rotating(pp6, radians= - math.atan(7/2) , about_point= [ 1.1 ,-1.3 , 0 ], run_time=1 ))
        self.play(pp6.animate.shift(( 3.15 -sqrt(1.93)- sqrt(2.21)-sqrt(1.6) -sqrt(2.12) )*LEFT + 1.8*UP))
        self.add(pp7)
        self.play(Rotating(pp7, radians= math.atan(7/11) - PI , about_point= [ 0 ,-0.6 , 0 ], run_time=1 ))
        self.play(pp7.animate.shift(( 2.05 -sqrt(1.93)- sqrt(2.21)-sqrt(1.6) -sqrt(2.12) - sqrt(1.7) )*LEFT + 1.1*UP))
        self.wait()
        a = Line([-4.85, 0.4, 0], [4.85 , 0.4,0] , color = BLUE )
        self.play(Create(a))
        self.wait()


class tin3(Scene):
    def construct(self):
        a = Line([-4.85, 0.4, 0], [4.85 , 0.4,0] , color = BLUE )
        self.add(a)
        c = Circle(radius = 1.6, color=WHITE).shift(1.9*DOWN)
        gam = Line([0,-0.6,0], [-1.2, -1.5, 0], color = BLUE).append_points(Line([-1.2,-1.5,0], [-0.7,-2.7,0], color=BLUE).points)
        gam.append_points(Line([-0.7,-2.7,0], [0.5,-2,0], color=BLUE).points).append_points(Line([0.5,-2,0], [-0.5,-3.1,0], color =BLUE).points)
        gam.append_points(Line([-0.5,-3.1,0],[ 0.7,-2.7, 0] , color=BLUE).points).append_points(Line([ 0.7,-2.7, 0], [1.1,-1.3,0] , color=BLUE).points)
        gam.append_points(Line([1.1,-1.3,0], [0,-0.6,0] , color=BLUE).points)
        p1 = Polygon([0,-0.6,0], [-1.2,-1.5,0], [0,-1.9,0], fill_color=RED ,color= RED, stroke_width =1   ,  fill_opacity = 0.3)
        p2 = Polygon([-1.2, -1.5,0], [-0.7,-2.7,0], [0,-1.9,0], fill_color=ORANGE ,color= ORANGE, stroke_width =1   ,  fill_opacity = 0.3)
        p3 = Polygon([-0.7,-2.7,0], [0.5,-2,0], [0,-1.9,0], fill_color=YELLOW ,color= YELLOW, stroke_width =1   ,  fill_opacity = 0.3)
        p4 = Polygon([0.5,-2,0], [-0.5,-3.1,0], [0,-1.9,0], fill_color=GREEN ,color= GREEN, stroke_width =1   ,  fill_opacity = 0.3)
        p5 = Polygon([-0.5,-3.1,0], [0.7,-2.7,0], [0,-1.9,0], fill_color=BLUE ,color= BLUE, stroke_width =1   ,  fill_opacity = 0.3)
        p6 = Polygon([0.7,-2.7,0], [1.1,-1.3,0], [0,-1.9,0], fill_color=PURPLE_E ,color= PURPLE_E, stroke_width =1   ,  fill_opacity = 0.3)
        p7 = Polygon( [1.1,-1.3,0] , [0,-0.6,0], [0,-1.9,0], fill_color=PINK ,color= PINK, stroke_width =1   ,  fill_opacity = 0.3)
        self.play(Create(c), Create(gam), Create(p1), Create(p2), Create(p3), Create(p4), Create(p5), Create(p6), Create(p7))
        pp1 = p1.copy()
        pp2 = p2.copy()
        pp3 = p3.copy()
        pp4 = p4.copy()
        pp5 = p5.copy()
        pp6 = p6.copy()
        pp7 = p7.copy()
        pp8 = p1.copy()
        b1 = Dot([0,-1.9, 0], radius =0)
        b2 = b1.copy()
        b3 = b1.copy()
        b4 = Dot([-1,-1.9, 0], radius =0)
        b5 = b1.copy()
        b6 = b1.copy()
        b7 = b1.copy()
        b8 = b1.copy()
        self.add(pp1)
        self.play(Rotating(pp1, radians= PI  - math.atan(3/4) , about_point= [ -1.2 ,-1.5 , 0 ] , run_time=1 ))
        self.play(pp1.animate.shift(2.15*LEFT + 2*UP))
        self.add(pp2)
        self.play(Rotating(pp2, radians= math.atan(12/5) , about_point= [ -0.7 ,-2.7 , 0 ], run_time=1 ))
        self.play(pp2.animate.shift(1.35*LEFT + 3.2*UP))
        self.add(pp3)
        self.play(Rotating(pp3, radians=  - math.atan(7/12) , about_point= [ 0.5 ,-2 , 0 ], run_time=1 ))
        self.play(pp3.animate.shift((2.55-sqrt(1.93))*LEFT + 2.5*UP))
        self.add(pp4)
        self.play(pp4.animate.become(Polygon([-1.5,-2,0], [-0.5,-3.1,0], [-1,-1.9,0], fill_color=GREEN ,color= GREEN, stroke_width =1   ,  fill_opacity = 0.3)    ))
        self.play(Rotating(pp4, radians=  math.atan(1.1) , about_point= [ -0.5 ,-3.1 , 0 ], run_time=1 ))
        self.play(pp4.animate.shift(( 1.55-sqrt(1.93)- sqrt(2.21))*LEFT + 3.6*UP))
        self.add(pp5)
        self.play(Rotating(pp5, radians= - math.atan(1/3) , about_point= [ 0.7 ,-2.7 , 0 ], run_time=1 ))
        self.play(pp5.animate.shift(( 2.75-sqrt(1.93)- sqrt(2.21)-sqrt(1.6) )*LEFT + 3.2*UP))
        self.add(pp6)
        self.play(Rotating(pp6, radians= - math.atan(7/2) , about_point= [ 1.1 ,-1.3 , 0 ], run_time=1 ))
        self.play(pp6.animate.shift(( 3.15 -sqrt(1.93)- sqrt(2.21)-sqrt(1.6) -sqrt(2.12) )*LEFT + 1.8*UP))
        self.add(pp7)
        self.play(Rotating(pp7, radians= math.atan(7/11) - PI , about_point= [ 0 ,-0.6 , 0 ], run_time=1 ))
        self.play(pp7.animate.shift(( 2.05 -sqrt(1.93)- sqrt(2.21)-sqrt(1.6) -sqrt(2.12) - sqrt(1.7) )*LEFT + 1.1*UP))
        self.add(pp8)
        self.play(Rotating(pp8, radians= PI - math.atan(3/4) , about_point= [ -1.2 ,-1.5 , 0 ], run_time=1 ))
        self.play(pp8.animate.shift((  sqrt(1.93)+ sqrt(2.21)+sqrt(1.6) +sqrt(2.12) + sqrt(1.7) + 0.65  )*RIGHT + 2*UP))
        b1.rotate( angle = PI  - math.atan(3/4) , about_point= [ -1.2 ,-1.5 , 0 ])
        b1.shift(2.15*LEFT + 2*UP )
        b2.rotate( angle = math.atan(12/5) , about_point= [ -0.7 ,-2.7 , 0 ])
        b2.shift(1.35*LEFT + 3.2*UP )
        b3.rotate( angle = - math.atan(7/12) , about_point= [ 0.5 ,-2 , 0 ])
        b3.shift((2.55-sqrt(1.93))*LEFT + 2.5*UP )
        b4.rotate( angle = math.atan(1.1) , about_point= [ -0.5 ,-3.1 , 0 ])
        b4.shift(( 1.55-sqrt(1.93)- sqrt(2.21))*LEFT + 3.6*UP )
        b5.rotate( angle = - math.atan(1/3) , about_point= [ 0.7 ,-2.7 , 0 ])
        b5.shift(( 2.75-sqrt(1.93)- sqrt(2.21)-sqrt(1.6) )*LEFT + 3.2*UP) 
        b6.rotate( angle = - math.atan(7/2) , about_point= [ 1.1 ,-1.3 , 0 ])
        b6.shift(( 3.15 -sqrt(1.93)- sqrt(2.21)-sqrt(1.6) -sqrt(2.12) )*LEFT + 1.8*UP )
        b7.rotate( angle = math.atan(7/11) - PI , about_point= [ 0 ,-0.6 , 0 ])
        b7.shift(( 2.05 -sqrt(1.93)- sqrt(2.21)-sqrt(1.6) -sqrt(2.12) - sqrt(1.7) )*LEFT + 1.1*UP )
        b8.rotate(angle = PI  - math.atan(3/4) , about_point= [ -1.2 ,-1.5 , 0 ])
        b8.shift((  sqrt(1.93)+ sqrt(2.21)+sqrt(1.6) +sqrt(2.12) + sqrt(1.7) + 0.65  )*RIGHT + 2*UP)
        bet = Line(b1.get_center(), b2.get_center(), color = YELLOW).append_points(Line(b2.get_center(), b3.get_center(), color = YELLOW).points)
        bet.append_points(Line(b3.get_center(), b4.get_center(), color = YELLOW).points).append_points(Line(b4.get_center(), b5.get_center(), color = YELLOW).points)
        bet.append_points(Line(b5.get_center(), b6.get_center(), color = YELLOW).points).append_points(Line(b6.get_center(), b7.get_center(), color = YELLOW).points)
        bet.append_points(Line(b7.get_center(), b8.get_center(), color = YELLOW).points)
        self.wait()
        self.play(Create(bet), run_time = 2)
        self.wait()
        l0 = DashedLine([-1.2,-1.5,0], [-2.4,-2.4, 0])
        l00 = Line([-1.2,-1.5, 0], [-0.7, -2.7, 0])
        ang0 = Angle(l0, l00, radius=0.3, other_angle=False)
        th0 = Tex(r"$\theta_1$", font_size=20).next_to(ang0, DOWN).shift(0.1*UP)
        l1 = Line([-3.35, 0.5, 0], b1)
        l11 = Line([-3.35,0.5,0], b2)
        ang1 = Angle(l11,l1, radius =0.3 , other_angle=False)
        th1 = Tex(r"$\theta_1^{\prime}$", font_size =20).next_to(ang1,UP).shift(0.15*DOWN)
        self.play(Create(l0), Create(ang0), Create(th0), Create(ang1), Create(th1))
        self.wait()
        th1pnp = Tex(r"$\theta_1^{\prime} = \theta_1$", font_size =20).shift(1.8*UP + 3.35 * LEFT)
        self.play(Write(th1pnp))
        self.wait()
        l2 = DashedLine([-0.7,-2.7,0], [-0.2,-3.9,0])
        l22 = Line( [-0.7, -2.7, 0], [0.5, -2,0])
        ang2 = Angle(l2, l22, radius=0.3, other_angle=False)
        th2 = Tex(r"$\theta_2$", font_size=20).next_to(ang2, DOWN).shift(0.3*RIGHT+0.4*UP)
        l2p = Line([-2.05, 0.5, 0], b2)
        l22p = Line([-2.05,0.5,0], b3)
        ang2p = Angle(l22p,l2p, radius =0.3 , other_angle=False)
        th2p = Tex(r"$\theta_2^{\prime}$", font_size =20).next_to(ang2p,UP).shift(0.1*DOWN + 0.2*RIGHT)
        self.play(Create(l2), Create(ang2), Create(th2), Create(ang2p), Create(th2p))
        self.wait()
        th2pnp = Tex(r"$\theta_2^{\prime} = \theta_2$", font_size =20).shift(1.8*UP + 2.05 * LEFT)
        self.play(Write(th2pnp))
        self.wait()
        l3 = DashedLine([0.5, -2,0], [1.7,-1.3,0])
        l33 = Line( [0.5, -2,0], [-0.5, -3.1,0])
        ang3 = Angle(l33, l3, radius=0.3, other_angle=False)
        th3 = Tex(r"$\theta_3$", font_size=20).next_to(ang3, DOWN).shift(0.3*RIGHT+0.4*UP)
        l3p = Line([-2.05 + sqrt(1.93), 0.5, 0], b3)
        l33p = Line([-2.05 + sqrt(1.93) ,0.5,0], b4)
        ang3p = Angle(l33p,l3p, radius =0.3 , other_angle=False)
        th3p = Tex(r"$\theta_3^{\prime}$", font_size =20).next_to(ang3p,UP).shift(0.1*DOWN)
        self.play(Create(l3), Create(ang3), Create(th3), Create(ang3p), Create(th3p))
        self.wait()
        th3pnp = Tex(r"$\theta_3^{\prime} <  \theta_3$", font_size =20).shift(1.8*UP + (2.05 - sqrt(1.93))* LEFT)
        self.play(Write(th3pnp))
        self.wait()
        t2g = Group(l2,th2,ang2)
        self.play(FadeOut(t2g))
        self.wait()
        l4 = DashedLine( [-0.5,-3.1,0],[-1.5,-4.2,0])
        l44 = Line(  [-0.5, -3.1,0], [0.7,-2.7,0])
        ang4 = Angle(l4, l44, radius=0.3, other_angle=False)
        th4 = Tex(r"$\theta_4$", font_size=20).next_to(ang4, DOWN).shift(0.3*RIGHT+0.4*UP)
        l4p = Line([-2.05 + sqrt(1.93) + sqrt(2.21), 0.5, 0], b4)
        l44p = Line([-2.05 + sqrt(1.93) + sqrt(2.21) ,0.5,0], b5)
        ang4p = Angle(l44p,l4p, radius =0.3 , other_angle=False)
        th4p = Tex(r"$\theta_4^{\prime}$", font_size =20).next_to(ang4p,UP).shift(0.1*DOWN)
        self.play(Create(l4), Create(ang4), Create(th4), Create(ang4p), Create(th4p))
        self.wait()
        th4pnp = Tex(r"$\theta_4^{\prime} <  \theta_4$", font_size =20).shift(1.8*UP + (2.05 - sqrt(1.93)-sqrt(2.21))* LEFT)
        self.play(Write(th4pnp))
        self.wait()
        t3g = Group(l3,th3,ang3)
        self.play(FadeOut(t3g))
        self.wait()
        l5 = DashedLine([0.7,-2.7,0], [1.9,-2.3,0])
        l55 = Line( [0.7, -2.7, 0], [1.1, -1.3,0])
        ang5 = Angle(l5, l55, radius=0.3, other_angle=False)
        th5 = Tex(r"$\theta_5$", font_size=20).next_to(ang5, RIGHT).shift(0.2*UP+0.2*LEFT)
        l5p = Line([-2.05+ sqrt(1.93) + sqrt(2.21) + sqrt(1.6), 0.5, 0], b5)
        l55p = Line([-2.05+ sqrt(1.93) + sqrt(2.21) + sqrt(1.6),0.5,0], b6)
        ang5p = Angle(l55p,l5p, radius =0.3 , other_angle=False)
        th5p = Tex(r"$\theta_5^{\prime}$", font_size =20).next_to(ang5p,UP).shift(0.1*DOWN)
        th5pnp = Tex(r"$\theta_5^{\prime} = \theta_5$", font_size =20).shift(1.8*UP + (2.05-sqrt(1.93) - sqrt(2.21) - sqrt(1.6)) * LEFT)
        #6
        l6 = DashedLine( [1.1, -1.3,0],[1.5,0.1,0])
        l66 = Line(  [1.1, -1.3,0],[0,-0.6,0])
        ang6 = Angle(l6, l66, radius=0.3, other_angle=False)
        th6 = Tex(r"$\theta_6$", font_size=20).next_to(ang6, UP).shift(0.1*LEFT+0.1*DOWN)
        l6p = Line([-2.05+ sqrt(1.93) + sqrt(2.21) + sqrt(1.6)+sqrt(2.12), 0.5, 0], b6)
        l66p = Line([-2.05+ sqrt(1.93) + sqrt(2.21) + sqrt(1.6)+sqrt(2.12),0.5,0], b7)
        ang6p = Angle(l66p,l6p, radius =0.3 , other_angle=False)
        th6p = Tex(r"$\theta_6^{\prime}$", font_size =20).next_to(ang6p,UP).shift(0.1*DOWN)
        th6pnp = Tex(r"$\theta_6^{\prime} = \theta_6$", font_size =20).shift(1.8*UP + (2.05-sqrt(1.93) - sqrt(2.21) - sqrt(1.6)-sqrt(2.12)) * LEFT)
        #7
        l7 = DashedLine([0,-0.6,0], [-1.1,0.1,0])
        l77 = Line( [0,-0.6,0], [-1.2,-1.5,0])
        ang7 = Angle(l7, l77, radius=0.3, other_angle=False)
        th7 = Tex(r"$\theta_7$", font_size=20).next_to(ang7, LEFT).shift(0.1*RIGHT)
        l7p = Line([-2.05+ sqrt(1.93) + sqrt(2.21) + sqrt(1.6)+sqrt(2.12) + sqrt(1.7), 0.5, 0], b7)
        l77p = Line([-2.05+ sqrt(1.93) + sqrt(2.21) + sqrt(1.6)+sqrt(2.12) + sqrt(1.7),0.5,0], b8)
        ang7p = Angle(l77p,l7p, radius =0.3 , other_angle=False)
        th7p = Tex(r"$\theta_7^{\prime}$", font_size =20).next_to(ang7p,UP).shift(0.1*DOWN)
        th7pnp = Tex(r"$\theta_7^{\prime} = \theta_7$", font_size =20).shift(1.8*UP + (2.05-sqrt(1.93) - sqrt(2.21) - sqrt(1.6)-sqrt(2.12) - sqrt(1.7)) * LEFT)
        #allth = Group(l5,ang5,th5,ang5p,th5p, th5pnp ,l6,ang6,th6,ang6p,th6p, th6pnp ,l7,ang7,th7,ang7p,th7p, th7pnp )
        self.play(Create(l5),Create(ang5),Create(th5),Create(ang5p),Create(th5p),Create(th5pnp),Create(l6),Create(ang6),Create(th6),Create(ang6p),Create(th6p),Create(th6pnp),Create(l7),Create(ang7),Create(th7),Create(ang7p),Create(th7p),Create(th7pnp))
        self.wait()
        final = Tex(r"$\Phi (\gamma ) = \sum \theta_i \geq \sum \theta_i^{\prime} \geq $ length$($ $) \geq$ length$($ $) = $ length$(\gamma )$.", font_size =32).shift(2.5*UP)
        yc = Line([ 0.25,2.525,0],[0.4,2.525,0],color=YELLOW)
        bc = Line([1.98,2.525,0],[2.13,2.525,0],color=BLUE)
        self.play(Write(final), Create(yc), Create(bc))
        box = SurroundingRectangle(final, buff = .1, color = PINK)
        self.play(Create(box))






class poly(Scene):
    def construct(self):
        p = Polygon([0,0,0], [1,1,0], [-1,1,0], [0,0,0], fill_color=RED ,color= RED,  fill_opacity = 0.5)
        self.play(Create(p))
        self.wait()        