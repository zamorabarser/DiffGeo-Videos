from fnmatch import translate
from this import d
from tkinter import E
from manim import *
from numpy import sqrt




class ticf(Scene):
    def construct(self):
        t1 = Text("Crofton formulas", font_size=60)
        self.play(Write(t1))
        self.wait(3) 
        self.play(FadeOut(t1))
        self.wait()       



class set(Scene):
    def construct(self):
        set = Tex(r"$\lambda (\gamma ): = \frac{1}{4}\int_0^{2 \pi} $length$(\gamma _ {v(\theta)})$d$\theta$.")
        b = SurroundingRectangle(set, buff = .25, color = PINK)
        self.play(Write(set))
        self.play(Create(b))
        self.wait()


class conclude(Scene):
    def construct(self):
        conc = Tex(r"We can conclude:").to_edge(UL).shift(DOWN+RIGHT)
        set = Tex(r"$\lambda (\gamma ) = $length$(\gamma )$ for all $\gamma$.").shift(0.85*UP)
        b = SurroundingRectangle(set, buff = .25, color = PINK)
        self.play(Write(conc), Write(set))
        self.play(Create(b))
        self.wait()
        cf = Tex(r"length$(\gamma ) = \frac{1}{4}\int_0^{2 \pi}$length$(\gamma_{v(\theta )})$d$\theta$ for all $\gamma$.").shift(DOWN)
        bcf = SurroundingRectangle(cf, buff = .25, color = RED)
        self.play( Write(cf))
        self.play(Create(bcf))
        self.wait()
        


class const(Scene):
    def construct(self):
        ti = Tex(r"Crofton formula", font_size = 40, color = RED).to_edge(UL)
        v0 = ti.get_left()[0]
        li = Tex(r"For a vector $v \in \mathbb{S}^1$ and a point $x \in \mathbb{R}^2$, let ", font_size = 36).next_to(ti,DOWN)
        form = Tex(r"$x_v : = \langle x, v \rangle v$.", font_size = 36).next_to(li, DOWN)
        li.shift((v0 - li.get_left()[0])*RIGHT)
        form.shift(form.get_center()[0]*LEFT)
        self.play(Write(ti), Write(li), Write(form))
        self.wait(2)
        x = Dot([-1/2,1,0], color = BLUE)
        xlabel = Tex(r"$x$", font_size = 36).next_to(x,(0.5)* DOWN + (0.7)* LEFT)
        xbox = SurroundingRectangle(xlabel, buff = .1, color = BLUE)
        zer = Dot([0,-2,0], color = WHITE)
        zerlabel = Tex(r"$0$", font_size = 36).next_to(zer,(0.3)* DOWN + (0.3)* LEFT)
        v = Arrow([0,-2,0],[2/3,-1,0], color = YELLOW , stroke_width = 10).scale(1.5)
        vlabel = Tex(r"$v$", font_size = 36).next_to(v,  (0.1)* RIGHT + (0.05)*DOWN )
        vbox = SurroundingRectangle(vlabel, buff = .1, color = YELLOW)
        lin = DashedLine([0,-2,0], [2,1,0], color = WHITE ,stroke_width = 2 )
        self.play(Create(lin), Create(zer), Create(v), Create(x), Create(xlabel), Create(xbox), Create(zerlabel), Create(vlabel), Create(vbox))
        self.wait(2)
        lin2 = DashedLine(x.get_center(), [16/13,-2/13,0], color = WHITE ,stroke_width = 2 )
        xv = Dot([16/13,-2/13,0], color = ORANGE)
        xvlabel = Tex(r"$x_v$", font_size = 36).next_to(xv,(0.5)* DOWN + (0.6)* RIGHT)
        xvbox = SurroundingRectangle(xvlabel, buff = .1, color = ORANGE)
        self.play(Create(lin2), Create(xv), Create(xvlabel), Create(xvbox))
        self.wait(2)
        picture = Group(x,xlabel, xbox, zer, zerlabel, v, vlabel, vbox, lin, lin2, xv, xvlabel, xvbox)
        self.play(FadeOut(picture))
        vtheta = Tex(r"Set $v(\theta ) : = ( \cos (\theta ) , \sin ( \theta )  )$. Then", font_size = 36).next_to(form, DOWN)
        vtheta.shift((v0 - vtheta.get_left()[0])*RIGHT )
        cform  = Tex(r"length$(\gamma ) = \dfrac{1}{4} \int_0^{2 \pi} $length$\left( \gamma_{v(\theta)} \right) $ d$ \theta$.", font_size = 36).next_to(vtheta, DOWN)
        cform.shift(cform.get_center()[0]*LEFT)
        cbox = SurroundingRectangle(cform, buff = .1, color = RED)
        self.play(Write(vtheta), Write(cform), Create(cbox))
        self.wait()
        cur = ParametricFunction(lambda t : [ (0.6)* np.sin(2*t)  , np.cos(t) - 1.5 ,0], t_range = [-PI,PI ] , color = RED)
        self.play(Create(cur), Create(zer))
        self.wait()
        l0 = DashedLine([0,-3,0], [0,0,0], color = WHITE ,stroke_width = 2 )
        self.play(Create(l0))
        g0 = ParametricFunction(lambda t : [ 0 , np.cos(t) - 1.5 ,0], t_range = [-PI,PI ] , color = BLUE)
        gg = cur.copy().set_color(BLUE)
        self.play(Transform(gg,g0))
        self.play(FadeOut(gg), FadeOut(l0))
        self.wait()
        l1 = DashedLine([-0.8,-2.8,0], [1.6,-0.4,0], color = WHITE ,stroke_width = 2 )
        self.play(Create(l1))
        g1 = ParametricFunction(lambda t : [ ((0.6)*np.sin(2*t)+np.cos(t)+0.5 )/2 , ((0.6)*np.sin(2*t)+np.cos(t) +0.5 )/2 - 2,0], t_range = [-PI,PI ] , color = BLUE)
        gg = cur.copy().set_color(BLUE)
        self.play(Transform(gg,g1))
        self.play(FadeOut(gg), FadeOut(l1))
        self.wait()
        l2 = DashedLine([-1.5,-2,0], [1.5,-2,0], color = WHITE ,stroke_width = 2 )
        self.play(Create(l2))
        g2 = ParametricFunction(lambda t : [ (0.6)*np.sin(2*t) ,  -2  ,0], t_range = [-PI,PI ] , color = BLUE)
        gg = cur.copy().set_color(BLUE)
        self.play(Transform(gg,g2))
        self.play(FadeOut(gg), FadeOut(l2))
        self.wait()
        l3 = DashedLine([0.8,-2.8,0],[-1.6,-0.4,0], color = WHITE ,stroke_width = 2 )
        self.play(Create(l3))
        g3 = ParametricFunction(lambda t : [ ((0.6)*np.sin(2*t)-np.cos(t)-0.5 )/2 , (-(0.6)*np.sin(2*t)+np.cos(t) +0.5 )/2 - 2  ,0], t_range = [-PI,PI ] , color = BLUE)
        gg = cur.copy().set_color(BLUE)
        self.play(Transform(gg,g3))
        self.play(FadeOut(gg), FadeOut(l3))
        self.wait()





class norm(Scene):
    def construct(self):
        lin = Tex(r"Let $\gamma $ be a line of length $L$", font_size = 40).to_edge(UL).shift(RIGHT+(0.5)*DOWN)
        self.play(Write(lin))
        self.wait()
        dot = DashedLine([-3,0.5,0], [3,0.5,0])
        gam = Line([-2,-1.5,0], [2,2.5,0], color = RED)
        gamlabel = Tex(r"$\gamma$", font_size = 36).next_to(gam, RIGHT ).shift((0.5)*LEFT + UP)
        gambox = SurroundingRectangle(gamlabel, buff = .1, color = RED)
        self.play(Create(gamlabel), Create(gambox), Create(gam)) 
        self.wait()
        v = Arrow([0,0.5,0],[1.2,0.5,0], color = YELLOW , stroke_width = 10).scale(1.5)
        vlabel = Tex(r"$v$", font_size = 36).next_to(v, DOWN )
        vbox = SurroundingRectangle(vlabel, buff = .1, color = YELLOW)
        self.play(Create(dot), Create(vlabel), Create(vbox), Create(v))
        self.wait()
        proj = Line([-2,0.5,0], [2,0.5,0], color = BLUE )
        gg = gam.copy()
        projlabel = Tex(r"$\gamma _ v$", font_size = 36).next_to(proj, DOWN).shift((1.5)*LEFT)
        projbox = SurroundingRectangle(projlabel, buff = .1, color = BLUE)  
        self.play(Transform(gg,proj), Create(projlabel), Create(projbox))
        self.remove(v)
        self.add(v)
        self.wait()
        form = Tex(r"The length of $\gamma _v$ is $L \vert \cos ( v, \gamma ) \vert $ ", font_size = 40).to_edge(UL).shift(5.5*DOWN+RIGHT)
        lef = form.get_left()[0]
        self.wait()
        self.play(Write(form))
        self.wait()
        form2 = Tex(r"$\int_0^{2 \pi}$ length$\left( \gamma _{v (\theta )}  \right)$d$\theta = \int_0^{2 \pi} L \vert \cos (\theta )  \vert $d$\theta = 4L $", font_size = 40).next_to(form, DOWN)
        form2.shift((form2.get_left()[0]-lef)*LEFT)
        self.play(Write(form2))
        self.wait()
        la = Tex(r"$\lambda (\gamma) = $length$(\gamma)$", font_size = 40).shift(2.7*RIGHT+1.2*DOWN)
        lab = SurroundingRectangle(la, buff = .2, color = PINK)
        self.play(Write(la))
        self.play(Create(lab))
        self.wait()



class repa(Scene):
    def construct(self):
        tit = Tex(r"If $\gamma_2$, $\gamma_1$ are equivalent reparametrizations, $\gamma_2 = \gamma_1 \circ \phi$, and", font_size = 40).to_edge(UL).shift(RIGHT+(0.5)*DOWN)
        g12v = Tex(r"$\Rightarrow \gamma_2 (t)_v = \gamma_1(\phi(t)) _v$ for each $t$, and each $v \in \mathbb{S}^1$", font_size = 40).next_to(tit, DOWN)
        h0 = g12v.get_left()[0]
        g12v2 = Tex(r"$\Rightarrow \left( \gamma_2 \right)_v = \left( \gamma_1  \right) _v \circ \phi $", font_size = 40).next_to(g12v, DOWN)
        g12v2.shift((h0- g12v2.get_left()[0])*RIGHT)
        g12v3 = Tex(r"$\Rightarrow$ length$\left( \left( \gamma_2 \right)_v \right) = $ length$ \left( \left( \gamma_1  \right) _v \right) $ for each $v\in \mathbb{S}^1$", font_size = 40).next_to(g12v2, DOWN)
        g12v3.shift((h0-g12v3.get_left()[0])*RIGHT)
        self.play(Write(tit))
        self.play(Write(g12v))
        self.play(Write(g12v2))
        self.play(Write(g12v3))
        cur1 = ParametricFunction(lambda t : [ (t - PI/2 ) / 2 , 1.2* np.sin( t ) -2.1 ,0], t_range = [0 , PI ] , color = WHITE)
        lin = DashedLine([-1,-3,0],[1,0,0], color = WHITE ,stroke_width = 2 )
        self.play(Create(cur1), Create(lin))
        d1 = Dot(cur1.get_start(), color = BLUE)
        d2 = Dot(cur1.get_start(), color = ORANGE)
        cur2 =  ParametricFunction(lambda t : [ ((t - PI/2 )  + 3* 1.2* np.sin( t ) - 6.3 + 9/2 )*2/14 , ((t - PI/2 )  + 3* 1.2* np.sin( t ) - 6.3 + 9/2 )*3/14 - 3/2  ,0], t_range = [0 , PI ] , color = WHITE)    
        d1s = Dot(cur2.get_start(), color = BLUE)
        d2s = Dot(cur2.get_start(), color = ORANGE)
        self.play(Create(d1), Create(d2), Create(d1s), Create(d2s))
        self.play(MoveAlongPath(d1,cur1, rate_func=rate_functions.ease_in_sine),MoveAlongPath(d2,cur1), MoveAlongPath(d1s,cur2, rate_func=rate_functions.ease_in_sine),MoveAlongPath(d2s,cur2), run_time = 3)   
        self.wait(2)



class repa2(Scene):
    def construct(self):
        tit = Tex(r"If $\gamma_2$, $\gamma_1$ are equivalent reparametrizations, $\gamma_2 = \gamma_1 \circ \phi$, and", font_size = 40).to_edge(UL).shift(RIGHT+(0.5)*DOWN)
        g12v = Tex(r"$\Rightarrow \gamma_2 (t)_v = \gamma_1(\phi(t)) _v$ for each $t$, and each $v \in \mathbb{S}^1$", font_size = 40).next_to(tit, DOWN)
        h0 = g12v.get_left()[0]
        g12v2 = Tex(r"$\Rightarrow \left( \gamma_2 \right)_v = \left( \gamma_1  \right) _v \circ \phi $", font_size = 40).next_to(g12v, DOWN)
        g12v2.shift((h0- g12v2.get_left()[0])*RIGHT)
        g12v3 = Tex(r"$\Rightarrow$ length$\left( \left( \gamma_2 \right)_v \right) = $ length$ \left( \left( \gamma_1  \right) _v \right) $ for each $v\in \mathbb{S}^1$", font_size = 40).next_to(g12v2, DOWN)
        g12v3.shift((h0-g12v3.get_left()[0])*RIGHT)
        self.add(tit , g12v, g12v2, g12v3)
        cform  = Tex(r"$\int_0^{2 \pi} $length$\left( \gamma_1 \right)_{v(\theta)} $ d$ \theta = \int_0^{2 \pi} $length$\left( \gamma_2 \right)_{v(\theta)} $ d$ \theta $", font_size = 36).shift(1*DOWN)
        self.play(Write(cform))
        box1 = SurroundingRectangle(cform, buff = .09, color = ORANGE)
        box2 = SurroundingRectangle(cform, buff = .15, color = BLUE)
        self.play(Create(box1), Create(box2))
        la = Tex(r"$\lambda (\gamma_1) = \lambda (\gamma_2)$", font_size = 36).shift(2.5*DOWN)
        lab = SurroundingRectangle(la, buff = .2, color = PINK)
        self.play(Write(la))
        self.play(Create(lab))
        self.wait()
        


class conc(Scene):
    def construct(self):
        tit = Tex(r"If $\alpha$ ends right where $\beta$ starts,", font_size = 40).to_edge(UL).shift(RIGHT+(0.5)*DOWN)
        conc = Tex(r"$\Rightarrow (\alpha \ast \beta )_v = \alpha _v  \ast \beta _v  $", font_size = 40).next_to(tit, DOWN)
        h0 = tit.get_left()[0]
        conc.shift((conc.get_left()[0] - h0) * LEFT)
        self.play(Write(tit), Write(conc))
        cura = ParametricFunction(lambda t : [ t-PI/2,  np.sin(t) ,0], t_range = [0 , PI/2 ] , color = BLUE)
        curb = ParametricFunction(lambda t : [ t , (t-1)**2  ,0], t_range = [0 , 1] , color = GREEN)
        self.play(Create(cura))
        self.play(Create(curb))   
        lin = DashedLine([-2,-1,0],[2,-0.5,0], color = WHITE ,stroke_width = 2 )
        self.play(Create(lin))    
        curap =  ParametricFunction(lambda t : [ (8* t- 4* PI +  np.sin(t) - 1/2) * 8 /65 ,  (8* t- 4* PI +  np.sin(t) - 1/2)  /65  - 3/4  ,0], t_range = [0 , PI/2 ] , color = BLUE)
        curbp = ParametricFunction(lambda t : [  (8*t + (t-1)**2  - 1/2  )*8 /65 , (8*t + (t-1)**2  - 1/2  ) /65  - 3/4  ,0], t_range = [0 , 1] , color = GREEN)
        self.wait()
        self.play(Create(curap))
        self.play(Create(curbp))
        self.wait()
        cform  = Tex(r"$\int_0^{2 \pi} $length$\left( ( \alpha \ast \beta )_{v(\theta)} \right) $ d$ \theta = \int_0^{2 \pi} $length$\left(  \alpha _{v(\theta)} \right) $ d$ \theta  +  \int_0^{2 \pi} $length$\left(  \beta _{v(\theta)} \right) $ d$ \theta $", font_size = 36).shift(2.2*DOWN)
        self.play(Write(cform))
        box1 = SurroundingRectangle(cform, buff = .08, color = GREEN)
        box2 = SurroundingRectangle(cform, buff = .13, color = BLUE)
        self.play(Create(box1), Create(box2))
        self.wait()
        la = Tex(r"$\lambda (\alpha \ast \beta ) = \lambda (\alpha ) + \lambda (\beta )$", font_size = 36).shift(1.9*UP + 2.8*RIGHT)
        lab = SurroundingRectangle(la, buff = .2, color = PINK)
        self.play(Write(la))
        self.play(Create(lab))
        self.wait()



class isom(Scene):
    def construct(self):
        tit = Tex(r"If $T : \mathbb{R}^2 \to \mathbb{R}^2$ is an isometry,", font_size = 40).to_edge(UL).shift(RIGHT+(0.5)*DOWN)
        cur = ParametricFunction(lambda t : [ 2*t - 3.5 ,  np.sin(  3 * t*PI /2 ) + 0.5 ,0], t_range = [0 , 1 ] , color = BLUE)
        curp = cur.copy()
        lin = DashedLine([-4,-0.5,0],[-1,0.5,0], color = WHITE ,stroke_width = 2 )
        g = Tex(r"$\gamma$", font_size = 40).next_to(cur, UP)
        gbox = SurroundingRectangle(g, buff = .08, color = BLUE)
        curs = ParametricFunction(lambda t : [ ( 6*t - 10.5 +  np.sin(  3 * t*PI /2 )  + 8 ) *3 / 10  - 5/2 , ( 6*t - 10.5 +  np.sin(  3 * t*PI /2 )  + 8 )  / 10 ,0], t_range = [0 , 1 ] , color = GREEN)
        self.play(Write(tit))
        self.play(Create(cur), Create(lin), Create(g), Create(gbox))  
        self.play(Transform(curp, curs)) 
        curpp = cur.copy()
        curspp = curs.copy()
        linpp = lin.copy()
        curt = ParametricFunction(lambda t : [ -  np.sin(  3 * t*PI /2 ) +2.5 , 2*t -0.5  ,0], t_range = [0 , 1 ] , color = RED)
        curst = ParametricFunction(lambda t : [ -( 6*t - 10.5 +  np.sin(  3 * t*PI /2 ) - 22 ) / 10 , ( 6*t - 10.5 +  np.sin(  3 * t*PI /2 )  + 8 ) *3 / 10  +0.5 ,0], t_range = [0 , 1 ] , color = ORANGE) 
        lint = DashedLine([3.5,-1,0],[2.5,2,0], color = WHITE ,stroke_width = 2 )
        tg = Tex(r"$T \circ \gamma$", font_size = 40).next_to(curt, UP).shift(2*RIGHT + DOWN)
        tgbox = SurroundingRectangle(tg, buff = .08, color = RED)
        self.play(Transform(curpp,curt), Transform(linpp, lint), Transform(curspp, curst), Write(tg), Create(tgbox))
        form = Tex(r"$\Rightarrow$ $T( \gamma _v )  = (T \gamma)_{Rot(T)v} $", font_size = 40).shift((1.5)*DOWN+ 2.8*LEFT)
        ll = form.get_left()[0]
        under1 = Line([-0.2,-1.9,0], [0.25,-1.9,0], color= GREEN)
        under2 = Line([-0.5,-2,0], [0.4,-2,0], color= ORANGE)
        under3 = Line([2.7,-1.9,0], [3.2,-1.9,0], color= RED)
        under4 = Line([2.6,-2,0], [4.1,-2,0], color= ORANGE)
        form2 = Tex(r"$\Rightarrow$ length$( \gamma _v )  = $ length$( T ( \gamma_v)) = $ length$\left( (T \gamma)_{Rot(T)v} \right) $", font_size = 40).next_to(form, DOWN)
        form2.shift((ll - form2.get_left())*RIGHT+0.2*DOWN)
        form3 = Tex(r"$\Rightarrow$   $\int_{0}^{2 \pi} $ length$( \gamma _{v ( \theta )} ) $d$\theta   =  \int_0^{2 \pi }$ length$\left( (T \gamma)_{v(\theta ) } \right) $d$\theta$", font_size = 40).next_to(form2, DOWN)
        form3.shift((ll - form3.get_left())*RIGHT)
        #self.play(Write(form))
        form2.shift(0.8*UP)
        form3.shift(0.6*UP)
        self.play(Write(form2))
        self.play(Create(under1),Create(under2), Create(under3), Create(under4) )
        self.play(Write(form3))
        self.wait()
        la = Tex(r"$\lambda (\gamma ) =  \lambda (T \circ \gamma )$", font_size = 36).shift(2.8*UP + 2.8*RIGHT)
        lab = SurroundingRectangle(la, buff = .2, color = PINK)
        self.play(Write(la))
        self.play(Create(lab))
        self.wait()





class lsem(Scene):
    def construct(self):
        tit = Tex(r"If $\gamma_n \to \gamma $ pointwise,", font_size = 40).to_edge(UL).shift(RIGHT+(0.5)*DOWN)
        lef = tit.get_left()[0]
        cons = Tex(r"then $(\gamma_n ) _v \to ( \gamma ) _v$", font_size = 40).next_to(tit, DOWN)
        cons.shift((cons.get_left()[0]-lef)*LEFT)
        gam = ParametricFunction(lambda t : [  -1.5 + (0.6)* t  ,  np.sin(  t  ) +1 ,0], t_range = [0 , TAU ] , color = BLUE)
        lab = Tex(r"$\gamma$", font_size = 40).next_to(gam, UP).shift(0.2*LEFT+0.1*DOWN)
        labb = SurroundingRectangle(lab, color = BLUE)
        gam1 = ParametricFunction(lambda t : [  -1.5 + (0.6)* t  ,  np.sin(  t  ) +1 -  (0.3 )* np.sin( 2*t )  ,0], t_range = [0 , TAU ] , color = GREEN)
        lab1 = Tex(r"$\gamma_1$", font_size = 40).next_to(gam, UP).shift((0.8)*LEFT+1.2*DOWN)
        lab1b = SurroundingRectangle(lab1, color = GREEN)
        lab2 = Tex(r"$\gamma_2$", font_size = 40).next_to(gam, UP).shift((0.8)*LEFT+1.2*DOWN)
        lab2b = SurroundingRectangle(lab1, color = YELLOW)
        lab3 = Tex(r"$\gamma_3$", font_size = 40).next_to(gam, UP).shift((0.8)*LEFT+1.2*DOWN)
        lab3b = SurroundingRectangle(lab1, color = ORANGE)
        lab4 = Tex(r"$\gamma_4$", font_size = 40).next_to(gam, UP).shift((0.8)*LEFT+1.2*DOWN)
        lab4b = SurroundingRectangle(lab1, color = RED)
        gam2 = ParametricFunction(lambda t : [  -1.5 + (0.6)* t  ,  np.sin(  t  ) +1 -  (0.2 )* np.sin( 4*t ) ,0], t_range = [0 , TAU ] , color = YELLOW)
        gam3 = ParametricFunction(lambda t : [  -1.5 + (0.6)* t  ,  np.sin(  t  ) +1 -  (0.1 )* np.sin( 8*t ) ,0], t_range = [0 , TAU ] , color = ORANGE) 
        gam4 = ParametricFunction(lambda t : [  -1.5 + (0.6)* t  ,  np.sin(  t  ) +1 -  (0.05 )* np.sin( 12*t ) ,0], t_range = [0 , TAU ] , color = RED) 
        dots = DashedLine([1.5,-2,0],[4,1.5,0], color = WHITE ,stroke_width = 4 )
        self.play(Write(tit))
        self.play(Create(gam), Write(lab), Create(labb))
        self.wait()
        self.play(Create(gam1), Write(lab1), Create(lab1b))
        self.play(Transform(gam1, gam2),Transform(lab1, lab2),Transform(lab1b, lab2b) )
        self.play(Transform(gam1, gam3),Transform(lab1, lab3),Transform(lab1b, lab3b) )
        self.play(Transform(gam1, gam4),Transform(lab1, lab4),Transform(lab1b, lab4b) )
        self.wait()
        self.play(FadeOut(gam1), FadeOut(lab1), FadeOut(lab1b))
        self.wait()
        self.play(Write(cons))
        gam1 = ParametricFunction(lambda t : [  -1.5 + (0.6)* t  ,  np.sin(  t  ) +1 -  (0.3 )* np.sin( 2*t )  ,0], t_range = [0 , TAU ] , color = GREEN)
        lab1 = Tex(r"$\gamma_1$", font_size = 40).next_to(gam, UP).shift((0.8)*LEFT+1.2*DOWN)
        lab1b = SurroundingRectangle(lab1, color = GREEN)
        gam1 = ParametricFunction(lambda t : [  -1.5 + (0.6)* t  ,  np.sin(  t  ) +1 -  (0.3 )* np.sin( 2*t )  ,0], t_range = [0 , TAU ] , color = GREEN)
        self.play(Create(dots))
        gamp = ParametricFunction(lambda t : [  1+ (-12.5 + 3* t  + 7*np.sin(  t  ) +   259/10)*5/74 , (-12.5 + 3* t  + 7*np.sin(  t  ) +  259/10)*7/74 - (27/10) ,0], t_range = [0 , TAU ] , color = BLUE)
        gam1p = ParametricFunction(lambda t : [ 1+ (-12.5 + 3* t  + 7*np.sin(  t  ) +  259/10  -  (2.1 )* np.sin( 2*t ) )*5/74 , (-12.5 + 3* t  + 7*np.sin(  t  ) +   259/10 -  (2.1 )* np.sin( 2*t ))*7/74 - (27/10) ,0], t_range = [0 , TAU ] , color = GREEN)
        gam2p = ParametricFunction(lambda t : [ 1+ (-12.5 + 3* t  + 7*np.sin(  t  ) +  259/10  -  (1.4 )* np.sin( 4*t ) )*5/74 , (-12.5 + 3* t  + 7*np.sin(  t  ) +   259/10 -  (1.4 )* np.sin( 4*t ))*7/74 - (27/10) ,0], t_range = [0 , TAU ] , color = YELLOW)
        gam3p = ParametricFunction(lambda t : [ 1+ (-12.5 + 3* t  + 7*np.sin(  t  ) +  259/10  -  (0.7 )* np.sin( 8*t ) )*5/74 , (-12.5 + 3* t  + 7*np.sin(  t  ) +   259/10 -  (0.7 )* np.sin( 8*t ))*7/74 - (27/10) ,0], t_range = [0 , TAU ] , color = ORANGE)
        gam4p = ParametricFunction(lambda t : [ 1+ (-12.5 + 3* t  + 7*np.sin(  t  ) +  259/10  -  (0.35 )* np.sin( 12*t ) )*5/74 , (-12.5 + 3* t  + 7*np.sin(  t  ) +   259/10 -  (0.35 )* np.sin( 12*t ) )*7/74 - (27/10) ,0], t_range = [0 , TAU ] , color = RED)
        labp = Tex(r"$\gamma _v$", font_size = 40).next_to(gamp, RIGHT).shift(0.2*RIGHT+0.1*UP)
        labpb = SurroundingRectangle(labp, color = BLUE)
        lab1p = Tex(r"$ ( \gamma_1) _v$", font_size = 40).next_to(gam1p, RIGHT).shift(0.6*LEFT+0.6*DOWN)
        lab1pb = SurroundingRectangle(lab1p, color = GREEN)
        lab2p = Tex(r"$ ( \gamma_2) _v$", font_size = 40).next_to(gam1p, RIGHT).shift(0.6*LEFT+0.6*DOWN)
        lab2pb = SurroundingRectangle(lab1p, color = YELLOW)
        lab3p = Tex(r"$ ( \gamma_3) _v$", font_size = 40).next_to(gam1p, RIGHT).shift(0.6*LEFT+0.6*DOWN)
        lab3pb = SurroundingRectangle(lab1p, color = ORANGE)
        lab4p = Tex(r"$ ( \gamma_4) _v$", font_size = 40).next_to(gam1p, RIGHT).shift(0.6*LEFT+0.6*DOWN)
        lab4pb = SurroundingRectangle(lab1p, color = RED)
        dum = gam.copy()
        dum1 = gam1.copy()
        dum2 = gam2.copy()
        dum3 = gam3.copy()
        dum4 = gam4.copy()
        self.play(Transform(dum, gamp),  Write(labp),  Create(labpb)) 
        self.wait()
        self.play(Create(gam1), Write(lab1), FadeIn(lab1b))
        self.play(Transform(dum1, gam1p),Write(lab1p), FadeIn(lab1pb))    
        self.play(FadeOut(dum1), FadeOut(lab1p), FadeOut(lab1pb), FadeOut(gam1), FadeOut(lab1), FadeOut(lab1b)) 
        self.play(Create(gam2), Write(lab2), FadeIn(lab2b))
        self.play(Transform(dum2, gam2p), Write(lab2p), FadeIn(lab2pb)) 
        self.play(FadeOut(dum2), FadeOut(lab2p), FadeOut(lab2pb), FadeOut(gam2), FadeOut(lab2), FadeOut(lab2b)) 
        self.play(Create(gam3), Write(lab3), FadeIn(lab3b))
        self.play(Transform(dum3, gam3p), Write(lab3p), FadeIn(lab3pb)) 
        self.play(FadeOut(dum3), FadeOut(lab3p), FadeOut(lab3pb), FadeOut(gam3), FadeOut(lab3), FadeOut(lab3b)) 
        self.play(Create(gam4), Write(lab4), FadeIn(lab4b))
        self.play(Transform(dum4, gam4p), Write(lab4p), FadeIn(lab4pb)) 
        #self.play(FadeOut(dum4), FadeOut(lab4p), FadeOut(lab4pb), FadeOut(gam4), FadeOut(lab4), FadeOut(lab4b)) 
        self.wait() 
        form1 = Tex(r"$ \int_0 ^{2 \pi } $ length$(\gamma _{v(\theta )} ) $d$\theta $", font_size = 40).shift(4*LEFT+(0.5)*DOWN)
        ll = form1.get_left()[0]
        form2 = Tex(r"$ \leq  \int_0 ^{2 \pi } \liminf $ length$((\gamma_n ) _{v(\theta )} ) $d$\theta $", font_size = 40).next_to(form1, DOWN)
        form2.shift((form2.get_left()-ll)*LEFT)
        form3 = Tex(r"$ \leq \liminf  \int_0 ^{2 \pi }  $ length$((\gamma_n ) _{v(\theta )} ) $d$\theta $", font_size = 40).next_to(form2, DOWN)
        form3.shift((form3.get_left()-ll)*LEFT)
        equa = Group(form1, form2, form3)
        boxes = SurroundingRectangle(equa,buff = .12,  color = ORANGE)
        self.play(Write(form1))
        self.wait()
        self.play(Write(form2))
        self.wait()
        self.play(Write(form3))
        self.wait()
        self.play(Create(boxes))
        self.wait()
        la = Tex(r"$\lambda (\gamma ) \leq  \liminf \lambda ( \gamma _n )$", font_size = 36).shift(2.8*DOWN + 2.8*RIGHT)
        lab = SurroundingRectangle(la, buff = .2, color = PINK)
        self.play(Write(la))
        self.play(Create(lab))
        self.wait()




class test3d(ThreeDScene):
    def construct(self):
        self.renderer.camera.light_source.move_to(0) # changes the source of the light
        axes = ThreeDAxes(z_range=(- 2, 2, 1/2), z_length = 4)
        param = Tex(r"$\gamma : [a,b] \to \mathbb{R}^3$", font_size=40)
        coor = Tex(r"$\gamma ( t) = (x(t), y(t),z(t))$",font_size =40)
        param.to_edge(UL).shift(RIGHT+0.7*DOWN)
        ll = param.get_left()[0]
        coor.next_to(param, DOWN)
        coor.shift((ll-coor.get_left()[0])*RIGHT)
        gam = ParametricFunction(lambda t : [ (2*TAU -2*t/3)*np.cos(-t) / TAU , (2*TAU - 2*t/3)*np.sin(-t)/TAU, (t - TAU)/4    ], t_range = [0 , 2 * TAU ] , color = BLUE)
        self.set_camera_orientation(phi=70 * DEGREES, theta=45 * DEGREES, distance = 8)
        self.add_fixed_in_frame_mobjects(param)
        self.add(axes)
        self.wait(3)
        self.play(Create(gam), run_time = 4)
        self.begin_ambient_camera_rotation(rate=TAU/10)
        self.wait(5)
        self.wait(5)
        self.stop_ambient_camera_rotation()
        self.wait(2)
        self.add_fixed_in_frame_mobjects(coor)
        self.wait(2)




 

class len(ThreeDScene):
    def construct(self):
        self.renderer.camera.light_source.move_to(0) # changes the source of the light
        axes = ThreeDAxes(z_range=(- 2, 2, 1/2), z_length = 4)
        param = Tex(r"$\gamma : [a,b] \to \mathbb{R}^3$", font_size=40)
        len2 = Tex(r"length$(\gamma) = \sup \sum_{j=1}^m \vert \gamma (t_j)-\gamma (t_{j-1} ) \vert $",font_size =40)
        param.to_edge(UL).shift(RIGHT+0.2*DOWN)
        bg = SurroundingRectangle(param, color = BLUE)
        len2.to_edge(UR).shift(0.2*DOWN)
        ble = SurroundingRectangle(len2, color = ORANGE)
        gam = ParametricFunction(lambda t : [ (2*TAU -2*t/3)*np.cos(-t) / TAU , (2*TAU - 2*t/3)*np.sin(-t)/TAU, (t - TAU)/4    ], t_range = [0 , 2 * TAU ] , color = BLUE)
        self.set_camera_orientation(phi=70 * DEGREES, theta=45 * DEGREES, distance = 8)
        self.add_fixed_in_frame_mobjects(param, bg)
        self.add_fixed_in_frame_mobjects(len2, ble)
        self.add(axes, gam)
        self.wait(2)
        p0 = gam.point_from_proportion(0)
        p1 = gam.point_from_proportion(1/32)
        p2 = gam.point_from_proportion(2/32)
        p3 = gam.point_from_proportion(3/32)
        p4 = gam.point_from_proportion(4/32)
        p5 = gam.point_from_proportion(5/32)
        p6 = gam.point_from_proportion(6/32)
        p7 = gam.point_from_proportion(7/32)
        p8 = gam.point_from_proportion(8/32)
        p9 = gam.point_from_proportion(9/32)
        p10 = gam.point_from_proportion(10/32)
        p11 = gam.point_from_proportion(11/32)
        p12 = gam.point_from_proportion(12/32)
        p13 = gam.point_from_proportion(13/32)
        p14 = gam.point_from_proportion(14/32)
        p15 = gam.point_from_proportion(15/32)
        p16 = gam.point_from_proportion(16/32)
        p17 = gam.point_from_proportion(17/32)
        p18 = gam.point_from_proportion(18/32)
        p19 = gam.point_from_proportion(19/32)
        p20 = gam.point_from_proportion(20/32)
        p21 = gam.point_from_proportion(21/32)
        p22 = gam.point_from_proportion(22/32)
        p23 = gam.point_from_proportion(23/32)
        p24 = gam.point_from_proportion(24/32)
        p25 = gam.point_from_proportion(25/32)
        p26 = gam.point_from_proportion(26/32)
        p27 = gam.point_from_proportion(27/32)
        p28 = gam.point_from_proportion(28/32)
        p29 = gam.point_from_proportion(29/32)
        p30 = gam.point_from_proportion(30/32)
        p31 = gam.point_from_proportion(31/32)
        p32 = gam.point_from_proportion(1)
        bl1 = Line(p0,p8).append_points(Line(p8,p16).points).append_points(Line(p16,p24).points).append_points(Line(p24,p32).points).set_color(ORANGE)
        self.play(Create(bl1), run_time = 3)
        self.begin_ambient_camera_rotation(rate=TAU/10)
        self.wait(3)
        self.play(FadeOut(bl1))
        bl2 = Line(p0, p4).append_points(Line(p4,p8).points).append_points(Line(p8,p12).points).append_points(Line(p12,p16).points).append_points(Line(p16,p20).points)
        bl2.append_points(Line(p20,p24).points).append_points(Line(p24,p28).points).append_points(Line(p28,p32).points).set_color(ORANGE)
        bl3 = Line(p0,p2).append_points(Line(p2,p4).points).append_points(Line(p4, p6).points).append_points(Line(p6,p8).points).append_points(Line(p8,p10).points).append_points(Line(p10,p12).points)
        bl3.append_points(Line(p12,p14).points).append_points(Line(p14,p16).points).append_points(Line(p16,p18).points).append_points(Line(p18,p20).points)
        bl3.append_points(Line(p22,p24).points).append_points(Line(p24,p26).points).append_points(Line(p26,p28).points).append_points(Line(p28,p30).points).append_points(Line(p30,p32).points).set_color(ORANGE)
        self.play(Create(bl2), run_time = 3)
        self.wait(3)
        self.play(FadeOut(bl2))
        self.play(Create(bl3), run_time=3)   
        self.wait(3)
        self.play(FadeOut(bl3))
        self.wait(2)
        self.stop_ambient_camera_rotation()
        self.wait()


class colortest2(ThreeDScene):
    def construct(self):
        dx = Sphere([1,1,1], color = BLUE, radius = 0.08)
        dx.set_color(BLUE)
        dx2 = Sphere([0,0,0], color = BLUE, radius = 0.08)
        self.add(dx)
        self.add(dx2)
        self.wait()



class pro0test(ThreeDScene):
    def construct(self):
        self.renderer.camera.light_source.move_to(0) # changes the source of the light
        axes = ThreeDAxes(z_range=(- 2, 2, 1/2), z_length = 4)
        setup = Tex(r"For $v \in \mathbb{S}^2$, and $x \in \mathbb{R}^3$", font_size=40).to_edge(UL).shift(DOWN+RIGHT)
        xto = Tex(r"$x \rightarrow x_v$", font_size=40).to_edge(UR).shift((1.1)*DOWN+2*LEFT)
        form = Tex(r"$x_v : = \langle x, v \rangle v$", font_size=40).next_to(xto, DOWN)
        self.add_fixed_in_frame_mobjects(setup, xto, form)
        self.wait()


class pro0(ThreeDScene):
    def construct(self):
        self.renderer.camera.light_source.move_to(0) # changes the source of the light
        axes = ThreeDAxes(z_range=(- 2, 2, 1/2), z_length = 4)
        setup = Tex(r"For $v \in \mathbb{S}^2$, and $x \in \mathbb{R}^3$", font_size=40).to_edge(UL).shift(DOWN+RIGHT)
        xto = Tex(r"$x \rightarrow x_v$", font_size=40).to_edge(UR).shift((1.1)*DOWN+2*LEFT)
        form = Tex(r"$x_v : = \langle x, v \rangle v$", font_size=40).next_to(xto, DOWN)
        ulx = Line([3.3,2,0], [3.55,2,0], color = BLUE)
        ulxv = Line([4.2,2,0], [4.6,2,0], color = RED)
        ulx0 = Line([-2.7,2,0], [-2.45,2,0], color = BLUE)
        ulv = Line([-4.9,2,0], [-4.6,2,0], color = YELLOW)
        self.add_fixed_in_frame_mobjects(setup, xto, ulx, ulxv, ulx0, ulv, form)
        self.set_camera_orientation(phi=70 * DEGREES, theta=45 * DEGREES, distance = 8)
        self.add(axes)
        dx = Sphere([1,1,1], color = BLUE, radius = 0.08)
        dx.set_color(BLUE)
        v1 = Arrow([0,0,0], [0,0,2], color = YELLOW)
        v2 = Arrow([0,0,0], [ - 1 , 1 ,  sqrt(2) ], color=YELLOW)
        v3 = Arrow([0,0,0], [ 2 , 0 ,  0 ], color=YELLOW)
        dx1 = Sphere([0,0,1], color = RED, radius = 0.08) 
        dx1.set_color(RED)
        dx2 = Sphere([-sqrt(2)/4,sqrt(2)/4,1/2] , color= RED, radius = 0.08)
        dx2.set_color(RED)
        dx3 = Sphere([1,0,0], color = RED , radius = 0.08)
        dx3.set_color(RED)
        lin1 = DashedLine(dx.get_center(),dx1.get_center(), color = WHITE ,stroke_width = 2 )
        lin2 = DashedLine(dx.get_center(),dx2.get_center(), color = WHITE ,stroke_width = 2 )
        lin3 = DashedLine(dx.get_center(),dx3.get_center(), color = WHITE ,stroke_width = 2 )
        self.wait()
        self.play(Create(dx))
        self.wait()
        self.begin_ambient_camera_rotation(rate=TAU/20)
        self.wait()
        self.play(Create(v1))
        self.wait()
        d = dx.copy()
        self.play(Transform(d,dx1), Create(lin1), run_time = 2.5)
        self.wait(3)
        self.play(FadeOut(d), FadeOut(v1), FadeOut(lin1))
        self.wait()
        self.play(Create(v2))
        self.wait()
        d = dx.copy()
        self.play(Transform(d,dx2), Create(lin2), run_time = 2.5)
        self.wait(3)
        self.play(FadeOut(d), FadeOut(v2),FadeOut(lin2))
        self.wait()
        self.play(Create(v3))
        self.wait()
        d = dx.copy()
        self.play(Transform(d,dx3), Create(lin3), run_time = 2.5)
        self.wait(3)
        self.play(FadeOut(d), FadeOut(v3), FadeOut(lin3))
        self.wait()


class pro(ThreeDScene):
    def construct(self):
        self.renderer.camera.light_source.move_to(0) # changes the source of the light
        axes = ThreeDAxes(z_range=(- 2, 2, 1/2), z_length = 4)
        param = Tex(r"$\gamma : [a,b] \to \mathbb{R}^3$", font_size=40)
        param.to_edge(UL).shift(RIGHT+0.2*DOWN)
        bg = SurroundingRectangle(param, color = BLUE)
        defi = Tex(r"$\gamma \to \gamma_{v^{\perp}}$", font_size=40).next_to(param, DOWN)
        lin1 = Line([-5.15, 2.1,0],[ -4.85,2.1,0], color = BLUE  )
        lin2 = Line([-4.15, 2.1,0],[ -3.7,2.1,0], color = GREEN  )
        defi.shift(0.1*DOWN)
        gam = ParametricFunction(lambda t : [ (2*TAU -2*t/3)*np.cos(t) / TAU , (2*TAU - 2*t/3)*np.sin(-t)/TAU, (t - TAU)/4    ], t_range = [0 , 2 * TAU ] , color = BLUE)
        self.set_camera_orientation(phi=70 * DEGREES, theta=45 * DEGREES, distance = 8)
        self.add_fixed_in_frame_mobjects(param, bg, defi, lin1, lin2)
        self.add(axes, gam)
        self.wait(2)
        v1 = Arrow([0,0,0], [0,0,2], color = YELLOW)
        v2 = Arrow([0,0,0], [ - 1 , 1 ,  sqrt(2) ], color=YELLOW)
        v3 = Arrow([0,0,0], [ 2 , 0 ,  0 ], color=YELLOW)
        gam1 = ParametricFunction(lambda t : [ (2*TAU -2*t/3)*np.cos(t) / TAU , (2*TAU - 2*t/3)*np.sin(-t)/TAU, 0   ], t_range = [0 , 2 * TAU ] , color = GREEN)
        gam2 = ParametricFunction(lambda t : [ (2*TAU -2*t/3)*np.cos(t) / (TAU)    - ((2*TAU -2*t/3)*np.cos(t) / ( 4* TAU) - (2*TAU - 2*t/3)*np.sin(-t)/(4* TAU) - (t - TAU)/(8 *sqrt(2)) )       , (2*TAU - 2*t/3)*np.sin(-t)/TAU + ((2*TAU -2*t/3)*np.cos(t) / ( 4* TAU) - (2*TAU - 2*t/3)*np.sin(-t)/(4* TAU) - (t - TAU)/(8 *sqrt(2)) ) , (t - TAU)/4 + sqrt(2)*((2*TAU -2*t/3)*np.cos(t) / ( 4* TAU) - (2*TAU - 2*t/3)*np.sin(-t)/(4* TAU) - (t - TAU)/(8 *sqrt(2)) )    ], t_range = [0 , 2 * TAU ] , color = GREEN)
        gam3 = ParametricFunction(lambda t : [ 0 , (2*TAU - 2*t/3)*np.sin(-t)/TAU, (t - TAU)/4    ], t_range = [0 , 2 * TAU ] , color = GREEN)
        self.play(Create(v1))
        self.wait()
        dum = gam.copy()
        self.play(Transform(dum,gam1))
        self.wait()
        self.begin_ambient_camera_rotation(rate=TAU/10)
        self.wait(3)
        self.stop_ambient_camera_rotation()
        self.play(FadeOut(v1), FadeOut(dum))
        dum = gam.copy()
        self.play(Create(v2))
        self.wait()
        self.play(Transform(dum,gam2))
        self.wait()
        self.begin_ambient_camera_rotation(rate=TAU/10)
        self.wait(3)
        self.stop_ambient_camera_rotation()
        self.play(FadeOut(v2), FadeOut(dum))
        self.wait()
        dum = gam.copy()
        self.play(Create(v3))
        self.wait()
        self.play(Transform(dum,gam3))
        self.wait()
        self.begin_ambient_camera_rotation(rate=TAU/10)
        self.wait(3)
        self.stop_ambient_camera_rotation()
        self.play(FadeOut(v3), FadeOut(dum))
        self.wait()


class underlinetest(ThreeDScene):
    def construct(self):
        self.renderer.camera.light_source.move_to(0) # changes the source of the light
        axes = ThreeDAxes(z_range=(- 2, 2, 1/2), z_length = 4)
        param = Tex(r"$\gamma : [a,b] \to \mathbb{R}^3$", font_size=40)
        param.to_edge(UL).shift(RIGHT+0.2*DOWN)
        defi = Tex(r"$\gamma \to \gamma_v$", font_size=40).next_to(param, DOWN)
        lin1 = Line([-5, 2.1,0],[ -4.7,2.1,0], color = BLUE  )
        lin2 = Line([-4.1, 2.1,0],[ -3.7,2.1,0], color = GREEN  )
        defi.shift(0.1*DOWN)
        bg = SurroundingRectangle(param, color = BLUE)
        self.add_fixed_in_frame_mobjects(param, bg, defi, lin1, lin2)
        self.wait()


class proo(ThreeDScene):
    def construct(self):
        self.renderer.camera.light_source.move_to(0) # changes the source of the light
        axes = ThreeDAxes(z_range=(- 2, 2, 1/2), z_length = 4)
        param = Tex(r"$\gamma : [a,b] \to \mathbb{R}^3$", font_size=40)
        param.to_edge(UL).shift(RIGHT+0.2*DOWN)
        defi = Tex(r"$\gamma \to \gamma_v$", font_size=40).next_to(param, DOWN)
        lin1 = Line([-5, 2.1,0],[ -4.7,2.1,0], color = BLUE  )
        lin2 = Line([-4.1, 2.1,0],[ -3.7,2.1,0], color = GREEN  )
        defi.shift(0.1*DOWN)
        bg = SurroundingRectangle(param, color = BLUE)
        gam = ParametricFunction(lambda t : [ (2*TAU -2*t/3)*np.cos(t) / TAU , (2*TAU - 2*t/3)*np.sin(-t)/TAU, (t - TAU)/4    ], t_range = [0 , 2 * TAU ] , color = BLUE)
        self.set_camera_orientation(phi=70 * DEGREES, theta=45 * DEGREES, distance = 8)
        self.add_fixed_in_frame_mobjects(param, bg, defi, lin1, lin2)
        self.add(axes, gam)
        self.wait(2)
        v1 = Arrow([0,0,0], [0,0,2], color = YELLOW)
        v2 = Arrow([0,0,0], [ - 1 , 1 ,  sqrt(2) ], color=YELLOW)
        v3 = Arrow([0,0,0], [ 2 , 0 ,  0 ], color=YELLOW)
        gam1 = ParametricFunction(lambda t : [ 0,0,  (t - TAU)/4    ], t_range = [0 , 2 * TAU ] , color = GREEN)
        gam2 = ParametricFunction(lambda t : [  ((2*TAU -2*t/3)*np.cos(t) / ( 4* TAU) - (2*TAU - 2*t/3)*np.sin(-t)/(4* TAU) - (t - TAU)/(8 *sqrt(2)) )       , - ((2*TAU -2*t/3)*np.cos(t) / ( 4* TAU) - (2*TAU - 2*t/3)*np.sin(-t)/(4* TAU) - (t - TAU)/(8 *sqrt(2)) ) , - sqrt(2)*((2*TAU -2*t/3)*np.cos(t) / ( 4* TAU) - (2*TAU - 2*t/3)*np.sin(-t)/(4* TAU) - (t - TAU)/(8 *sqrt(2)) )    ], t_range = [0 , 2 * TAU ] , color = GREEN)
        gam3 = ParametricFunction(lambda t : [ (2*TAU -2*t/3)*np.cos(t) / TAU  ,0 , 0    ], t_range = [0 , 2 * TAU ] , color = GREEN)
        self.play(Create(v1))
        self.wait()
        dum = gam.copy()
        self.play(Transform(dum,gam1))
        self.wait()
        self.begin_ambient_camera_rotation(rate=TAU/10)
        self.wait(3)
        self.stop_ambient_camera_rotation()
        self.play(FadeOut(v1), FadeOut(dum))
        dum = gam.copy()
        self.play(Create(v2))
        self.wait()
        self.play(Transform(dum,gam2))
        self.wait()
        self.begin_ambient_camera_rotation(rate=TAU/10)
        self.wait(3)
        self.stop_ambient_camera_rotation()
        self.play(FadeOut(v2), FadeOut(dum))
        self.wait()
        dum = gam.copy()
        self.play(Create(v3))
        self.wait()
        self.play(Transform(dum,gam3))
        self.wait()
        self.begin_ambient_camera_rotation(rate=TAU/10)
        self.wait(3)
        self.stop_ambient_camera_rotation()
        self.play(FadeOut(v3), FadeOut(dum))
        self.wait()





class pro1(ThreeDScene):
    def construct(self):
        self.renderer.camera.light_source.move_to(0) # changes the source of the light
        axes = ThreeDAxes(z_range=(- 2, 2, 1/2), z_length = 4)
        setup = Tex(r"For $v \in \mathbb{S}^2$, and $x \in \mathbb{R}^3$", font_size=40).to_edge(UL).shift(DOWN+RIGHT)
        xto = Tex(r"$x \rightarrow x_{v^{\perp } }$", font_size=40).to_edge(UR).shift((1.1)*DOWN+2*LEFT)
        form = Tex(r"$ x_{v^{\perp } } : = x- x_v$", font_size=40).next_to(xto, DOWN)
        ulx = Line([3.1,2,0], [3.4,2,0], color = BLUE)
        ulxv = Line([3.95,2,0], [4.6,2,0], color = GREEN)
        ulx0 = Line([-2.7,2,0], [-2.45,2,0], color = BLUE)
        ulv = Line([-4.9,2,0], [-4.6,2,0], color = YELLOW)
        self.add_fixed_in_frame_mobjects(setup, xto, ulx, ulxv, ulx0, ulv, form)
        self.set_camera_orientation(phi=70 * DEGREES, theta=45 * DEGREES, distance = 8)
        self.add(axes)
        dx = Sphere([1,1,1], color = BLUE, radius = 0.08)
        dx.set_color(BLUE)
        v1 = Arrow([0,0,0], [0,0,2], color = YELLOW)
        v2 = Arrow([0,0,0], [ - 1 , 1 ,  sqrt(2) ], color=YELLOW)
        v3 = Arrow([0,0,0], [ 2 , 0 ,  0 ], color=YELLOW)
        dx1 = Sphere([1,1,0], color = GREEN, radius = 0.08) 
        dx2 = Sphere([1+sqrt(2)/4,1-sqrt(2)/4,1/2] , color= GREEN, radius = 0.08)
        dx3 = Sphere([0,1,1], color = GREEN , radius = 0.08)
        dx1.set_color(GREEN)
        dx2.set_color(GREEN)
        dx3.set_color(GREEN)
        lin1 = DashedLine(dx.get_center(),dx1.get_center(), color = WHITE ,stroke_width = 2 )
        lin2 = DashedLine(dx.get_center(),dx2.get_center(), color = WHITE ,stroke_width = 2 )
        lin3 = DashedLine(dx.get_center(),dx3.get_center(), color = WHITE ,stroke_width = 2 )
        pl1 = Surface ( lambda u, v: np.array([ u, v, 0  ]), v_range=[-2, 2], u_range=[- 2, 2], resolution=(10, 10), checkerboard_colors=[MAROON_B, MAROON_B])
        pl2 = Surface ( lambda u, v: np.array([ (u-v)/sqrt(2) , (u+v)/sqrt(2) , -v  ]), v_range=[-2, 2], u_range=[- 2, 2], resolution=(10, 10), checkerboard_colors=[MAROON_B, MAROON_B])
        pl3 = Surface ( lambda u, v: np.array([ 0 , u , v ]), v_range=[-2, 2], u_range=[- 2, 2], resolution=(10, 10), checkerboard_colors=[MAROON_B, MAROON_B])
        self.wait()
        self.play(Create(dx))
        self.wait()
        self.begin_ambient_camera_rotation(rate=TAU/20)
        self.wait()
        self.play(Create(v1), Create(pl1))
        self.wait()
        d = dx.copy()
        self.play(Transform(d,dx1), Create(lin1), run_time = 2.5)
        self.wait(3)
        self.play(FadeOut(d), FadeOut(v1), FadeOut(lin1), FadeOut(pl1))
        self.wait()
        self.play(Create(v2), Create(pl2))
        self.wait()
        d = dx.copy()
        self.play(Transform(d,dx2), Create(lin2), run_time = 2.5)
        self.wait(3)
        self.play(FadeOut(d), FadeOut(v2),FadeOut(lin2), FadeOut(pl2))
        self.wait()
        self.play(Create(v3), Create(pl3))
        self.wait()
        d = dx.copy()
        self.play(Transform(d,dx3), Create(lin3), run_time = 2.5)
        self.wait(3)
        self.play(FadeOut(d), FadeOut(v3), FadeOut(lin3),  FadeOut(pl3))
        self.wait()





class colortest(ThreeDScene):
    def construct(self):
        d = Surface ( lambda u, v: np.array([ u, v, 0  ]), v_range=[-2, 2], u_range=[- 2, 2], resolution=(10, 10), checkerboard_colors=[MAROON_B, MAROON_B])
        self.play(Create(d))
        self.wait()




class v23(Scene):
    def construct(self):
        ti2 = Tex(r"For $\gamma : [a,b] \to \mathbb{R}^2$", font_size =40).to_edge(UL)
        ti2.shift(0.7*DOWN)
        cf2 = Tex(r"length$(\gamma) = \frac{1}{4}\int_0^{2 \pi} $length$(\gamma _ {v(\theta)})$d$\theta$.", font_size=40).shift(1.5*UP)
        b = SurroundingRectangle(cf2, buff = .25, color = PINK)
        ti3 = Tex(r"For $\gamma : [a,b] \to \mathbb{R}^3$", font_size =40).to_edge(UL)
        ti3.shift(3.1*DOWN)
        cf3 = Tex(r"length$(\gamma) = \frac{1}{2 \pi }\int_{\mathbb{S}^2} $length$(\gamma _ {v})$d$v$.", font_size=40).shift(0.9*DOWN)
        cf32 = Tex(r"length$(\gamma) = \frac{1}{\pi ^2 }\int_{\mathbb{S}^2} $length$(\gamma _ {v^{\perp}})$d$v$.", font_size=40).shift(2.4*DOWN)
        b3 = SurroundingRectangle(cf3, buff = .25, color = PINK)
        b32 = SurroundingRectangle(cf32, buff = .25, color = PINK)
        self.play(Write(ti2), Write(cf2))
        self.play(Create(b))
        self.wait()
        self.play(Write(ti3), Write(cf3), Write(cf32))
        self.play(Create(b3), Create(b32))
        self.wait()