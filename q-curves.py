from tkinter import E
from manim import *
from numpy import sqrt




class de(Scene):
    def construct(self):
        ax = Axes(x_range = [-3,3], y_range = [-3,3]).scale((0.4)*RIGHT+(0.6)*UP).shift(4*RIGHT+(0.2)*UP)
        t= Tex(r"$t$", font_size = 45).move_to((1.7)*LEFT+(0.1)*DOWN)
        xya = ax.get_axis_labels()
        line = NumberLine(x_range = [-3,3, 1],include_tip=True, tip_width = 0.2, tip_height = 0.2).scale(0.65).shift(4*LEFT+(0.5)*DOWN)
        self.play(FadeIn(ax), FadeIn(t),FadeIn(line), FadeIn(xya))
        ar = CurvedArrow(LEFT, (0.8)* RIGHT+(0.6)*UP, radius = -3, tip_length = 0.2)
        gam = Tex(r"$\gamma$", font_size=58).next_to(ar,UP)
        dom = Line([-5.3,-0.5, 0], [-3.1,-0.5, 0], color = BLUE).set_height(0.2)
        d0 = Dot([-5.3,-0.5,0], color = BLUE)
        d1 = Dot([-3.1,-0.5,0], color = BLUE)
        a = dom.copy()
        b = d0.copy()
        c = d1.copy() 
        self.play(Create(dom), Create(d0), Create(d1), run_time=2)
        self.add(a,b,c)
        self.wait()
        self.play(Create(ar),Write(gam))
        self.wait()
        dot = Dot([2+0.4,-1/2,0], color=BLUE)
        d3 = dot.copy()
        trail = VMobject(color=BLUE)
        trail.set_points_as_corners([dot.get_center(), dot.get_center()])
        def update_path(trail):
            previous_path = trail.copy()
            previous_path.add_points_as_corners([dot.get_center()])
            trail.become(previous_path)
        trail.add_updater(update_path)
        sp = ParametricFunction(lambda t : [4+(0.8)*t,(t-2)*t*(t+2)/8+t/4,0], t_range = [-2,2], color = BLUE)
        self.play(FadeIn(dot), FadeIn(d3), FadeIn(trail))
        self.play(MoveAlongPath(dot, sp), run_time=5)
        self.wait()
        self.play(Transform(dom,sp), Transform(d0,d3), Transform(d1,dot), run_time = 3)
        self.wait()
        xy = Tex(r"$\gamma (t) = (x(t),y(t))$", font_size=45).move_to(-2*UP)
        box = SurroundingRectangle(xy, buff = .1, color = BLUE)
        self.play(Write(xy))
        self.wait()
        self.play(Create(box))
        self.wait()
        all = Group(box, xy, trail, d3, d1, d0, dom, gam, ar, t, ax, xya, dot, line, a , b, c)
        self.play(FadeOut(all))


class defi(Scene):
    def construct(self):
        ax = Axes(x_range = [-3,3, 0.25], y_range = [-3,3, 0.5])
        xya = ax.get_axis_labels()
        self.play(FadeIn(ax), FadeIn(xya))
        d1 = Dot([-4,-1,0], color=BLUE, radius=0.16)
        d2 = d1.copy().set_color(ORANGE)
        d3 = d1.copy().set_color(YELLOW)
        d4 = d1.copy().set_color(RED)
        sp = ParametricFunction(lambda t : [2*t,(t-2)*t*(t+2)/3+t/2,0], t_range = [-2,2])
        self.play(FadeIn(d1), FadeIn(d2), FadeIn(d4), FadeIn(d3),  FadeIn(sp))
        self.play(MoveAlongPath(d1,sp, rate_func=rate_functions.ease_in_sine), MoveAlongPath(d2,sp),MoveAlongPath(d3,sp, rate_func=rate_functions.ease_out_bounce),MoveAlongPath(d4,sp,rate_func=rate_functions.there_and_back),run_time=5)
        all = Group(ax, xya, d1, d2, d3, d4, sp)
        self.wait()
        self.play(FadeOut(all))
        
class param(Scene):
    def construct(self):        
        ax = Axes(x_range = [-3,3], y_range = [-3,3]).scale((0.4)*RIGHT+(0.6)*UP).shift(4*RIGHT)
        xya = ax.get_axis_labels()
        line1 = NumberLine(x_range = [-3,3, 1],include_tip=True, tip_width = 0.2, tip_height = 0.2).scale(0.65).shift(4*LEFT+(1.5)*UP)
        line2 = NumberLine(x_range = [-3,3, 1],include_tip=True, tip_width = 0.2, tip_height = 0.2).scale(0.65).shift(4*LEFT+(1.5)*DOWN)
        ar1 = CurvedArrow(LEFT+(1.5)*UP, (1.2)* RIGHT +(1.1)*UP , radius = - 3, tip_length = 0.2)
        ar2 = CurvedArrow(LEFT+(1.5)*DOWN, (1.2)* RIGHT +(1.1)*DOWN , radius = 3, tip_length = 0.2)
        gam1 = Tex(r"$\gamma_1$", font_size=58).next_to(ar1,UP)
        gam2 = Tex(r"$\gamma_2$", font_size=58).next_to(ar2,DOWN)
        dom1 = Line([-5.3,1.5, 0], [-3.1,1.5, 0], color = BLUE).set_height(0.2)
        dom2 = Line([-5.3,-1.5, 0], [-3.1,-1.5, 0], color = GREEN).set_height(0.2)
        d10 = Dot([-5.3,1.5,0], color = BLUE)
        d11 = Dot([-3.1,1.5,0], color = BLUE)
        d20 = Dot([-5.3,-1.5,0], color = GREEN)
        d21 = Dot([-3.1,-1.5,0], color = GREEN)
        p = Dot([2+0.4,-1/2,0])
        q = Dot([5.6,1/2,0])
        a = d10.copy()
        b = d11.copy()
        c = dom1.copy() 
        aa = d10.copy()
        bb = d11.copy()
        cc = dom1.copy()
        sp = ParametricFunction(lambda t : [4+(0.8)*t,(t-2)*t*(t+2)/8+t/4,0], t_range = [-2,2])        
        self.play(FadeIn(ax),  FadeIn(xya), FadeIn(p), FadeIn(q), FadeIn(sp))
        self.wait()
        self.play(FadeIn(line1), FadeIn(line2))
        self.play(Create(dom1),Create(dom2), Create(d10),Create(d11), Create(d20), Create(d21),FadeIn(aa), FadeIn(bb), FadeIn(cc), run_time=2)
        self.play(Create(ar1), Create(ar2),Write(gam1), Write(gam2))
        self.wait()
        v = Arrow(4*LEFT + UP, 4*LEFT + DOWN, tip_length = 0.2)
        phi = Tex(r"$\phi$", font_size=58).next_to(v,RIGHT)
        self.play(Create(v), Write(phi))
        self.wait()
        self.play(Transform(dom1,dom2), Transform(d10, d20), Transform(d11,d21), run_time=2)
        self.play(Transform(dom1,sp), Transform(d10, p), Transform(d11,q), run_time=2)
        self.play(FadeOut(dom1), FadeOut(d10), FadeOut(d11))
        self.wait()
        self.play(FadeIn(a), FadeIn(b), FadeIn(c) )
        self.play(Transform(a,p), Transform(b,q), Transform(c,sp), run_time=3)
        eq = Tex(r"$ \gamma_2 \circ \phi = \gamma_1$", font_size=58).shift((3.5)*DOWN)
        box = SurroundingRectangle(eq, buff = .1, color = YELLOW)
        self.play(Write(eq), run_time=2)
        self.play(Create(box))
        self.wait()
        

class param2(Scene):
    def construct(self):
        ax = Axes(x_range = [-3,3, 0.25], y_range = [-3,3, 0.5])
        sp = ParametricFunction(lambda t : [2*t,(t-2)*t*(t+2)/3+t/2,0], t_range = [-2,2])
        A = Group(ax,sp).scale(1/3)
        B = A.copy().shift((4.5)*LEFT)
        C = A.copy().shift((4.5)*RIGHT)
        self.play(FadeIn(A),FadeIn(B), FadeIn(C))
        d1 = Dot(color=BLUE).move_to(sp.get_start())
        d2 = d1.copy().set_color(ORANGE).shift((4.5)*LEFT)
        d3 = d1.copy().set_color(YELLOW).shift((4.5)*RIGHT)
        self.play(FadeIn(d1), FadeIn(d2), FadeIn(d3))
        self.play(MoveAlongPath(d1,sp, rate_func=rate_functions.ease_in_sine), MoveAlongPath(d2,B[1]),MoveAlongPath(d3,C[1], rate_func=rate_functions.ease_out_bounce), run_time=5)
        all = Group( d1, d2, d3, A, B, C)
        self.wait()
        self.play(FadeOut(all))


class tttest(Scene): 
    def construct(self):       
        t1 = Tex(r"Text 1")
        t2 = Tex(r"Text 2")
        self.add(t1)
        self.wait()
        self.play(Transform(t1,t2))
        self.wait()



class koch(Scene):
    def construct(self):
        ti = Tex(r"The Koch curve", font_size = 50).to_edge(UL).shift(0.5*DOWN+0.5*RIGHT)
        l0 = Line([-3,0,0], [3,0,0])
        def sf0(piece):
            p1 = piece.copy().scale(1/3).move_to([-2,0,0])
            p2 = p1.copy().move_to([2,0,0])
            p3 = p1.copy().rotate(PI/3).shift(sqrt(3)/2*UP +(1.5)* RIGHT)
            p4 = p3.copy().rotate(-2*PI/3).shift(RIGHT)
            newpiece = Group(p1,p2,p3,p4)
            return newpiece
        def sf(piece):
            p1 = piece.copy().scale(1/3).move_to([-2,0,0])
            p2 = p1.copy().move_to([2,0,0])
            p3 = p1.copy().rotate(PI/3, about_point=[-3,-1/(2*sqrt(3)),0]).shift(2* RIGHT)
            p4 = p1.copy().rotate(-PI/3, about_point = [-1,-1/(2*sqrt(3)), 0]).shift(2*RIGHT)
            newpiece = Group(p1,p2,p3,p4)
            return newpiece
        l1 = sf0(l0)
        l2 = sf(l1)
        l3 = sf(l2)
        l4 = sf(l3)
        l5 = sf(l4)
        l6 = sf(l5)
        len = Tex(r"Length =", font_size = 50).shift(2*DOWN+0.55*LEFT)
        len1 = Tex(r"$ 1$", font_size = 50).next_to(len, RIGHT)
        len2 = Tex(r"$  \frac{4}{3}$", font_size = 50).next_to(len, RIGHT)
        len3 = Tex(r"$ \left( \frac{4}{3} \right) ^2$ ", font_size = 50).next_to(len, RIGHT)
        len4 = Tex(r"$  \left( \frac{4}{3} \right) ^3$", font_size = 50).next_to(len, RIGHT)
        len5 = Tex(r"$  \left( \frac{4}{3} \right) ^4$", font_size = 50).next_to(len, RIGHT)
        len6 = Tex(r"$ \left( \frac{4}{3} \right) ^5$", font_size = 50).next_to(len, RIGHT)
        len7 = Tex(r"$ \infty$", font_size = 50).next_to(len, RIGHT)
        l0.shift(1/(2*sqrt(3))*DOWN)
        l1.shift(1/(2*sqrt(3))*DOWN)
        self.play(Create(l0), Write(ti), Write(len), Write(len1))
        self.wait()
        self.play(FadeOut(l0),FadeIn(l1), Transform(len1, len2))
        self.wait()
        self.play(FadeOut(l1), FadeIn(l2),Transform(len1, len3))
        self.wait()
        self.play(FadeOut(l2), FadeIn(l3),Transform(len1, len4))
        self.wait()
        self.play(FadeOut(l3), FadeIn(l4), Transform(len1, len5))
        self.wait()
        self.play(FadeOut(l4), FadeIn(l5),Transform(len1, len6))
        self.wait()
        self.play(FadeOut(l5), FadeIn(l6),Transform(len1, len7))
        self.wait()


class tech(Scene):
    def construct(self):
       t1 = Text("The curve is", font_size=30).to_edge(UL)
       bull1 = Tex(r"$\bullet $", font_size=44).next_to(t1,DOWN).shift((0.5)*DOWN)
       poss10 = Text("differentiable ", font_size=30, color = YELLOW).next_to(bull1,RIGHT)
       poss102 = Text(" if there is a parametrization ", font_size=30).next_to(poss10,RIGHT)
       poss103 = Text( "with ", font_size=30).next_to(bull1,DOWN).shift(RIGHT)
       xy1 = Tex(r"$x(t), y(t)$", font_size=44).next_to(poss103, RIGHT)
       poss11 = Text(" differentiable ", font_size=30, color = YELLOW).next_to(xy1,RIGHT)
       poss12 = Text(" functions.", font_size=30).next_to(poss11,RIGHT)
       diff = Group(bull1, poss10, poss102, poss103, xy1, poss11, poss12)
       bull2 = bull1.copy().shift((1.5)*DOWN)
       poss20 = Tex(r" $C^k$ ", font_size=44, color = BLUE).next_to(bull2,RIGHT)
       poss202 = Text(" if there is a parametrization ", font_size=30).next_to(poss20,RIGHT)
       poss203 = Text( "with ", font_size=30).next_to(bull2,DOWN).shift(RIGHT)
       xy2 = Tex(r"$x(t), y(t)$", font_size=44).next_to(poss203, RIGHT)
       poss21 = Tex("$C^k$", font_size=44, color = BLUE).next_to(xy2,RIGHT).shift((0.1)*RIGHT)
       poss22 = Text(" functions.", font_size=30).next_to(poss21,RIGHT)
       ck = Group(bull2, poss20, poss202, poss203, xy2, poss21, poss22)
       bull3 = bull2.copy().shift((1.5)*DOWN)
       poss30 = Text(" smooth ", font_size=30, color = GREEN).next_to(bull3,RIGHT)
       poss302 = Text(" if there is a parametrization ", font_size=30).next_to(poss30,RIGHT)
       poss303 = Text( "with ", font_size=30).next_to(bull3,DOWN).shift(RIGHT)
       xy3 = Tex(r"$x(t), y(t)$", font_size=44).next_to(poss303, RIGHT)
       poss31 = Text(" smooth ", font_size=30, color = GREEN).next_to(xy3,RIGHT)
       poss32 = Text(" functions.", font_size=30).next_to(poss31,RIGHT)
       smooth = Group(bull3, poss30, poss302, poss303, xy3, poss31, poss32)
       bull4 = bull3.copy().shift((1.5)*DOWN)
       poss40 = Text(" regular ", font_size=30, color = PINK).next_to(bull4,RIGHT)
       poss402 = Text(" if there is a ", font_size=30).next_to(poss40,RIGHT)
       c1param  = Tex(r"$C^1$", font_size=44).next_to(poss402, RIGHT)
       poss4030 = Text("-parametrization ", font_size=30).next_to(c1param,(0.9)*RIGHT)
       poss403 = Tex(r"$\gamma (t)$", font_size=44).next_to(bull4,DOWN+ (1.5)*RIGHT)
       xy4 = Text(" with ", font_size=30).next_to(poss403, RIGHT)
       poss41 = Tex(r"$\gamma ^{\prime}(t) \neq 0$" , font_size=44, color = PINK).next_to(xy4, RIGHT)
       poss42 = Text(" for all ", font_size=30, color=PINK).next_to(poss41,RIGHT)
       poss43 = Tex(r"$t.$", font_size=44, color=PINK).next_to(poss42,RIGHT)
       regular = Group(bull4, poss40, poss402, poss403, xy4, poss41, poss42, poss43, poss4030, c1param)
       self.play(Write(t1))
       self.wait()
       self.play(Write(diff[0]), Write(diff[1]), Write(diff[2]), Write(diff[3]), Write(diff[4]), Write(diff[5]), Write(diff[6]))
       self.wait()
       self.play(Write(ck[0]), Write(ck[1]), Write(ck[2]), Write(ck[3]), Write(ck[4]), Write(ck[5]), Write(ck[6]))
       self.wait()
       self.play(Write(smooth[0]), Write(smooth[1]), Write(smooth[2]), Write(smooth[3]), Write(smooth[4]), Write(smooth[5]), Write(smooth[6]))
       self.wait()
       self.play(Write(regular[0]), Write(regular[1]), Write(regular[2]), Write(regular[3]), Write(regular[4]), Write(regular[5]), Write(regular[6]), Write(regular[7]), Write(regular[8]), Write(regular[9]))
       self.wait()



class techni(Scene):
    def construct(self):
        techni = Tex(r"Some technicalities:", font_size = 44).to_edge(UL).shift(0.2*RIGHT)
        v0 = techni.get_left()[0]
        difcl = Tex(r"$\bullet $ A function $f : [a,b] \to \mathbb{R}$ is differentiable (resp. $C^k$, etc.)", font_size=40).next_to(techni,DOWN)
        difcl.shift((v0 - difcl.get_left())*RIGHT)
        difop = Tex(r"if it is the restriction of a differentiable (resp. $C^k$, etc.)", font_size = 40).next_to(difcl, DOWN)
        difop.shift((v0 - difop.get_left()[0])*RIGHT)
        difop2 = Tex(r"function defined on an open interval containing $[a,b]$.", font_size = 40).next_to(difop, DOWN)
        difop2.shift((v0 - difop2.get_left()[0])*RIGHT)
        smreg = Tex(r"$\bullet $ A curve is called ", r" smooth regular ", r" (resp. ", r"$C^k$ regular", r", etc) if", font_size=40).next_to(difop2,DOWN).shift(0.2*DOWN)
        smreg.shift((v0 - smreg.get_left())*RIGHT)
        smreg[1].shift(0.1*RIGHT)
        smreg[2].shift(0.2*RIGHT)
        smreg[3].shift(0.3*RIGHT)
        smreg[4].shift(0.4*RIGHT)
        boxsr = SurroundingRectangle(smreg[1], buff = .1, color = PURPLE)
        boxckr = SurroundingRectangle(smreg[3], buff = .1, color = RED)
        smregp = Tex(r"there is a reparametrization that is ", r"both smooth and regular", font_size = 40).next_to(smreg, DOWN)
        smregp.shift((v0 - smregp.get_left()[0])*RIGHT)
        smregp[1].shift(0.1*RIGHT)
        smregp2 = Tex(r"(resp. ", r"both $C^k$ and regular", r", etc.).", font_size = 40).next_to(smregp, DOWN)
        smregp2.shift((v0 - smregp2.get_left()[0])*RIGHT)
        smregp2[1].shift(0.1*RIGHT)
        smregp2[2].shift(0.2*RIGHT)
        boxsr2 = SurroundingRectangle(smregp[1], buff = .1, color = PURPLE)
        boxckr2 = SurroundingRectangle(smregp2[1], buff = .1, color = RED)
        smreg3 = Tex(r"This is not the same as being both smooth and regular.", font_size = 40).next_to(smregp2, DOWN)
        smreg3.shift((v0 - smreg3.get_left()[0])*RIGHT)
        self.play(Write(techni), Write(difcl), Write(difop), Write(difop2))
        self.wait()
        ax = Axes(x_range = [-3,3], y_range = [-3,3]).scale((0.4)*RIGHT+(0.6)*UP).shift(4*RIGHT+UP)
        t= Tex(r"$t$", font_size = 45).move_to((1.7)*LEFT+(1.4)*UP)
        line = NumberLine(x_range = [-3,3, 1],include_tip=True, tip_width = 0.2, tip_height = 0.2).scale(0.65).shift(4*LEFT+UP)
        ar = CurvedArrow(LEFT+(1.5)*UP, RIGHT+(1.5)*UP, radius = -3, tip_length = 0.2)
        gam = Tex(r"$\gamma$", font_size=58).next_to(ar,UP)
        dom = Line([-5.3,1, 0], [-3.1,1, 0], color = BLUE).set_height(0.2)
        domop = Line([-5.6,1, 0], [-2.8,1, 0], color = GREEN_D).set_height(0.2)
        d0 = Line([-5.3,1.1,0], [-5.3,0.9,0], color = BLUE)
        d1 = Line([-3.1,1.1,0], [-3.1,0.9,0], color = BLUE)
        al = Tex(r"$a$", font_size = 44).next_to(d0, UP)
        bl = Tex(r"$b$", font_size = 44).next_to(d1, UP)
        sp = ParametricFunction(lambda t : [4+(0.8)*t,(t-2)*t*(t+2)/8+t/4+5/4,0], t_range = [-2,2], color = BLUE)
        spop = ParametricFunction(lambda t : [4+(0.8)*t,(t-2)*t*(t+2)/8+t/4+5/4,0], t_range = [-2.2,2.2], color = GREEN_D)
        e1 = Dot(sp.get_start(), color = BLUE)
        e2 = Dot(sp.get_end(), color = BLUE)
        regpic = Group(ax,t,line, ar, gam, dom, d0, d1, al, bl, sp, e1, e2)
        l1 = ParametricFunction(lambda t : [-1 + t + PI/4, -2.5+t+PI/4,0], t_range = [-PI/4-1,-PI/4 ])#Line([-2,-4,0], [-1,-3,0])
        l2 = ParametricFunction(lambda t : [sqrt(2)* np.sin(t), sqrt(2)* np.cos(t)-3.5,0], t_range = [-PI/4, PI/4])
        l21 = ParametricFunction(lambda t : [sqrt(2)* np.sin(t), sqrt(2)* np.cos(t)-3.5,0], t_range = [-PI/4, 0])
        l22 = ParametricFunction(lambda t : [sqrt(2)* np.sin(t), sqrt(2)* np.cos(t)-3.5,0], t_range = [0, PI/4])
        l3 = ParametricFunction(lambda t : [ t + 1  - PI/4, - t + PI/4 -2.5,0], t_range = [PI/4,PI/4 +1 ])# Line([1,-3, 0], [2,-4,0])
        l = l1.copy().append_points(l2.points).append_points(l3.points)
        ds = Dot(l.get_start(), color = BLUE)
        dr = Dot(l.get_start(), color = ORANGE)
        regpic.shift(3*DOWN)
        domop.shift(3*DOWN)
        spop.shift(3*DOWN)
        self.play(FadeIn(regpic))
        self.wait()
        self.play(Create(domop), Create(spop))
        self.wait()
        self.play(FadeOut(regpic), FadeOut(domop), FadeOut(spop))
        self.wait()
        self.play(Write(smreg), Write(smregp), Write(smregp2), Write(smreg3))
        self.wait()
        self.play(Create(boxsr), Create(boxckr), Create(boxsr2), Create(boxckr2))
        self.wait()
        self.play(Create(l))#        self.play(Create(l1), Create(l2), Create(l3))
        self.wait()
        self.play(Create(ds))
        self.wait()
        self.play(MoveAlongPath(ds, l1), run_time=2, rate_func=rate_functions.ease_out_cubic )
        self.play(MoveAlongPath(ds, l21), run_time=1, rate_func=rate_functions.ease_in_cubic )
        self.play(MoveAlongPath(ds, l22), run_time=1, rate_func=rate_functions.ease_out_cubic )
        self.play(MoveAlongPath(ds, l3), run_time=2, rate_func=rate_functions.ease_in_cubic )
        self.play(FadeOut(ds))
        self.wait()
        self.play(Create(dr))
        self.wait()
        self.play(MoveAlongPath(dr, l), run_time=6)
        self.wait()
        alll = Group(techni, difcl, difop, difop2, smreg, boxsr, boxsr2, boxckr, boxckr2, smregp, smregp2, smreg3, l, dr)
        self.play(FadeOut(alll))
        








class regex(Scene):
    def construct(self):
        ax = Axes(x_range = [-4,4, 0.5], y_range = [-1,4, 0.5], x_length = 8, y_length = 5)
        sp = ax.plot(lambda x: sqrt(x**2), x_range = [-3,3], color = YELLOW)
        sp1 = ax.plot(lambda x: sqrt(x**2), x_range = [-3,0], color = YELLOW)
        sp2 = ax.plot(lambda x: sqrt(x**2), x_range = [0,3], color = YELLOW)
        A = Group(ax,sp, sp1, sp2).scale(0.7).shift(3*RIGHT)
        self.play(FadeIn(A))
        gam = Tex(r"$\gamma ( t) = $", font_size = 44).to_edge(UL).shift(DOWN + (0.6)*RIGHT)
        gam1 = Tex(r"$ \left( -e^{1/t}, e^{1/t}  \right) , $").next_to(gam, (0.9)*RIGHT).shift(RIGHT+(0.7)*UP)
        pos = Tex(r"$\left( e^{-1/t}, e^{-1/t} \right), $").next_to(gam1, DOWN)
        zer = Tex(r"$(0,0), $").next_to(pos, DOWN)
        tp =  Tex(r"$ t <  0 $", font_size = 44).next_to(gam1, RIGHT)
        tn = Tex(r"$ t >  0 $", font_size = 44).next_to(tp, 2*DOWN)
        tz = Tex(r"$ t =  0 $", font_size = 44).next_to(tn, 2*DOWN)
        key = Tex(r"$\{$", font_size = 170).shift((4.2)*LEFT + (2.1)*UP).scale(0.5*RIGHT + (1.4)*UP)
        d1 = Dot(color=BLUE).move_to(sp.get_start())
        gam.shift(0.2*DOWN)
        eq = Group(gam, pos, tp, tn, key, gam1, zer, tz).scale(0.8).shift(2*DOWN + (0.7)*LEFT)
        self.play(FadeIn(d1), FadeIn(eq))
        self.wait()
        box = SurroundingRectangle(eq, buff = .25, color = BLUE)
        self.play(Create(box))
        self.wait()
        self.play(MoveAlongPath(d1,sp1), rate_func=rate_functions.ease_out_cubic, run_time=2.5)
        self.play(MoveAlongPath(d1,sp2), rate_func=rate_functions.ease_in_cubic, run_time=2.5)
        all = Group( d1, A, eq, box)
        self.wait()
        self.play(FadeOut(all))
        


class regthm(Scene):
    def construct(self):
        thm = Tex("Theorem" , " (regular curves don't have cusps)",font_size = 45).to_edge(UL).shift((0.2)*RIGHT)
        thm[0].set_color(BLUE)
        l1 = Tex(r"Let $\gamma : (a,b) \to  \mathbb{R}^2$ be a regular curve. Then for any point",font_size = 44).next_to(thm, DOWN)
        xbal = l1.get_left()[0]
        l1.shift((xbal - thm.get_left()[0])*LEFT)
        l2 = Tex(r"$t_0 \in (a,b)$ there is a reparametrization $\alpha : (c,d ) \to \mathbb{R}^2$ and a", font_size=44).next_to(l1, DOWN)
        xbal = l2.get_left()[0]
        l2.shift((xbal - thm.get_left()[0])*LEFT)
        l3 = Tex(r"coordinate system $\overline{x}, \overline{y} : \mathbb{R}^2 \to \mathbb{R}$  in which $\alpha (t)$ looks like", font_size=44).next_to(l2, DOWN)
        xbal = l3.get_left()[0]
        l3.shift((xbal - thm.get_left()[0])*LEFT)
        l4 = Tex(r"$(t, f(t))$ for $f$ a $C^1$-function near $\gamma(t_0)$.", font_size = 44).next_to(l3, DOWN)
        xbal = l4.get_left()[0]
        l4.shift((xbal - thm.get_left()[0])*LEFT)
        self.play(Write(thm), Write(l1), Write(l2), Write(l3), Write(l4))
        self.wait()
        cur = ParametricFunction(lambda t : [  np.cos(t)*(1.2 + (np.sin(3*t)) /4) ,   np.sin(t)*(1.2 + (np.sin(3*t)) /4) -2.2 , 0], t_range = [0,TAU], color = BLUE)
        cur0 = ParametricFunction(lambda t : [  np.cos(t)*(1.2 + (np.sin(3*t)) /4) ,   np.sin(t)*(1.2 + (np.sin(3*t)) /4) -2.2 , 0], t_range = [2*PI/3,5*PI/6], color = BLUE)
        dot = Dot(cur.point_from_proportion(3/8), color = YELLOW)
        self.play(Create(cur))
        self.add(cur0)
        self.play(FadeIn(dot))
        self.wait()
        ax = Axes(x_range = [-1,4, 0.5], y_range = [-1,4, 0.5], x_length = 6, y_length = 5)
        labels = ax.get_axis_labels(x_label="\overline{x}", y_label="\overline{y}")
        system = Group(ax,labels)
        system.rotate(5*PI/32).scale(1/2.2).shift((1.5)*DOWN + LEFT )
        self.play(Create(ax), Write(labels), run_time = 3)
        self.play(FadeOut(cur))

        


class simple(Scene):
    def construct(self):
        cur = ParametricFunction(lambda t : [  np.cos(t)+t/2 -PI/4,   np.sin(t) , 0], t_range = [-PI/2,3*PI/2], color = RED).shift(3*LEFT+2*UP)
        self.play(Create(cur))
        cap = Tex(r"Curve", font_size = 44).shift(3*LEFT)
        self.play(Write(cap))
        curs = ParametricFunction(lambda t : [ sqrt(3)*t/12 + np.sin(t)/(2) , t/12 - sqrt(3)*np.sin(t)/(2) , 0], t_range = [0,3*TAU], color = BLUE).shift((1.8)*RIGHT+(1.5)*UP)
        self.play(Create(curs))
        caps = Tex(r"Simple Curve", font_size = 44).shift(3*RIGHT)
        self.play(Write(caps))
        curc = ParametricFunction(lambda t : [ np.sin(3*t) , np.cos(t) , 0], t_range = [0,TAU], color = ORANGE).shift(3*LEFT+(1.8)*DOWN)
        self.play(Create(curc))
        capc = Tex(r"Closed Curve", font_size = 44).shift(3*LEFT+(3.5)*DOWN)
        self.play(Write(capc))
        cursc = ParametricFunction(lambda t :  [  np.cos(t)*(1 + (np.sin(3*t))/5 ) ,   np.sin(t)*(1 + (np.sin(3*t))/5) , 0], t_range = [0,TAU], color = YELLOW).shift((3.2)*RIGHT+(1.7)*DOWN)
        self.play(Create(cursc))
        capsc = Tex(r"Simple Closed Curve", font_size = 44).shift(3*RIGHT+(3.5)*DOWN)
        self.play(Write(capsc))
        self.wait()
        allbutjordan = Group(cur, cap, curs, caps, curc, capc, capsc)
        self.play(cursc.animate.scale(2).move_to((1.5)*UP), FadeOut(allbutjordan))
        self.wait()
        joth = Tex("Theorem" , " (Jordan curve)",font_size = 45).to_edge(UL).shift((0.2)*RIGHT+ (5)*DOWN)
        joth[0].set_color(YELLOW)
        jost = Tex(r"Any Jordan (closed simple) curve separates $\mathbb{R}^2$ in two connected",font_size = 44).next_to(joth, DOWN)
        xbal = jost.get_left()[0]
        jost.shift((xbal - joth.get_left()[0] )* LEFT )
        jost2 = Tex(r"components, one of them bounded and the other unbounded.",font_size = 44).next_to(jost, DOWN)
        xbal = jost2.get_left()[0]
        jost2.shift((xbal - joth.get_left()[0] )* LEFT )
        self.play(Write(joth), Write(jost), Write(jost2))
        self.wait()
        self.play(FadeOut(joth), FadeOut(jost), FadeOut(jost2), FadeOut(cursc))


        

class concat(Scene):
    def construct(self): 
        ti = Tex(r"Concatenation", font_size = 58).to_edge(UL)
        ar1 = Arrow((2.5)*LEFT+(1.5)*UP, (1.5)* LEFT+DOWN  , tip_length = 0.2)
        ar2 = Arrow((2.5)*RIGHT+(1.5)*UP, (1.5)* RIGHT +DOWN , tip_length = 0.2)
        ar3 = Arrow((1.5)*UP, [0,-1,0], tip_length = 0.1)
        conc = Tex(r"$\gamma_1 \ast \gamma_2$", font_size=58).next_to(ar3,RIGHT)
        gam1 = Tex(r"$\gamma_1$", font_size=58).next_to(ar1,LEFT)
        gam2 = Tex(r"$\gamma_2$", font_size=58).next_to(ar2,RIGHT)
        dom1 = Line([-4.5,2, 0], [-1.5,2, 0], color = BLUE).set_height(0.2)
        dom2 = Line([4.5,2, 0], [1.5,2, 0], color = GREEN).set_height(0.2)
        d10 = Line([-4.5,1.9,0], [-4.5,2.1,0], color = BLUE)
        d11 =  Line([-1.5,1.9,0], [-1.5, 2.1,0], color = BLUE)
        d20 =  Line([1.5,1.9,0], [1.5, 2.1,0], color = GREEN)
        d21 =  Line([4.5,1.9,0], [4.5, 2.1,0], color = GREEN)
        sp1 = ParametricFunction(lambda t : [(0.8)*t-1.6,(t-2)*t*(t+2)/8+t/4-2,0], t_range = [-2,2], color = BLUE)
        sp2 = ParametricFunction(lambda t : [(0.8)*t, ((t-2)**2)/4 -2.5 ,0], t_range = [0,4], color = GREEN)        
        self.play(Write(ti), Create(ar1), Create(ar2),Write(gam1), Write(gam2),Create(dom1),Create(dom2), Create(d10),Create(d11), Create(d20), Create(d21), FadeIn(sp1), FadeIn(sp2))
        self.wait()
        self.play(ar1.animate.shift((1.5)*RIGHT), ar2.animate.shift((1.5)*LEFT), FadeOut(gam1), FadeOut(gam2), dom1.animate.shift((1.5)*RIGHT), d10.animate.shift((1.5)*RIGHT), d11.animate.shift((1.5)*RIGHT), dom2.animate.shift((1.5)*LEFT), d20.animate.shift((1.5)*LEFT), d21.animate.shift((1.5)*LEFT),  Transform(ar1, ar3), Transform(ar2, ar3), FadeIn(conc))
        self.wait()
        all = Group( dom1, dom2, d10, d11, d20, d21)
        arrows = Group(ar1, ar2, ar3)
        pw = Tex(r"The curve $\gamma_1 \ast \ldots \ast \gamma_k$ is ", r" piecewise",r" regular (resp.  smooth, etc)", font_size=44).shift(3*DOWN)
        pw.shift((ti.get_left()[0]-pw.get_left()[0])*RIGHT)
        pw[1].set_color(ORANGE)
        com = Tex(r"if each $\gamma_i$ is.", font_size = 44).next_to(pw,DOWN)
        com.shift((ti.get_left()[0]-com.get_left()[0])*RIGHT)
        self.play(Write(pw), all.animate.shift(0.5*UP), arrows.animate.shift(0.6*UP), sp1.animate.shift((0.7)*UP), conc.animate.shift(0.7*UP), sp2.animate.shift((0.7)*UP), Write(com))
        self.wait()






class closmo(Scene):
    def construct(self):
        tit = Tex(r"Closed Cuves and Smoothness", font_size = 50).to_edge(UL)
        self.play(Write(tit))
        circ = ParametricFunction(lambda t : [ np.sin(t) + 3 , np.cos(t) , 0], t_range = [0,TAU], color = BLUE)
        dom1 = ParametricFunction(lambda t : [ 0.3* t - TAU , 0 , 0], t_range = [0,TAU], color = BLUE)
        dom2 = ParametricFunction(lambda t : [ 0.3* t - (0.7)*TAU , 0 , 0], t_range = [0,TAU], color = BLUE)
        dom3 = ParametricFunction(lambda t : [ 0.3* t -(0.4)* TAU , 0 , 0], t_range = [0,TAU], color = BLUE)
        dom0 = ParametricFunction(lambda t : [ 0.9* t -  TAU , 0 , 0], t_range = [0,TAU], color = BLUE)
        self.play(Create(circ))
        self.wait()
        self.play(Create(dom0))
        self.wait()
        self.remove(dom0)
        self.add(dom1, dom2, dom3)
        self.play(Transform(dom1, circ),Transform(dom2, circ),Transform(dom3, circ), run_time = 3)
        self.wait()
        self.play(FadeOut(dom1, dom2, dom3, circ))
        self.wait()
        ci2 = ParametricFunction(lambda t : [ np.sin(3*t) + 3 , np.cos(t) , 0], t_range = [0,TAU], color = ORANGE)
        dom1 = ParametricFunction(lambda t : [ 0.3* t - TAU , 0 , 0], t_range = [0,TAU], color = ORANGE)
        dom2 = ParametricFunction(lambda t : [ 0.3* t - (0.7)*TAU , 0 , 0], t_range = [0,TAU], color = ORANGE)
        dom3 = ParametricFunction(lambda t : [ 0.3* t -(0.4)* TAU , 0 , 0], t_range = [0,TAU], color = ORANGE)
        dom0 = ParametricFunction(lambda t : [ 0.9* t -  TAU , 0 , 0], t_range = [0,TAU], color = ORANGE)
        self.play(Create(ci2))
        self.wait()
        self.play(Create(dom0))
        self.wait()
        self.remove(dom0)
        self.add(dom1, dom2, dom3)
        self.play(Transform(dom1, ci2),Transform(dom2,ci2 ),Transform(dom3, ci2), run_time = 3)
        self.wait()
        self.play(FadeOut(dom1, dom2, dom3, ci2))
        self.wait()
        ci3 = ParametricFunction(lambda t : [ 3* np.sin(t/2) + 1.5 ,3* np.sin(t/2)  + (0.5)* np.sin(t) -1.5 , 0], t_range = [0,TAU], color = YELLOW)
        dom1 = ParametricFunction(lambda t : [ 0.3* t - TAU , 0 , 0], t_range = [0,TAU], color = YELLOW)
        dom2 = ParametricFunction(lambda t : [ 0.3* t - (0.7)*TAU , 0 , 0], t_range = [0,TAU], color = YELLOW)
        dom3 = ParametricFunction(lambda t : [ 0.3* t -(0.4)* TAU , 0 , 0], t_range = [0,TAU], color = YELLOW)
        dom0 = ParametricFunction(lambda t : [ 0.9* t -  TAU , 0 , 0], t_range = [0,TAU], color = YELLOW)
        self.play(Create(ci3))
        self.wait()
        self.play(Create(dom0))
        self.wait()
        self.remove(dom0)
        self.add(dom1, dom2, dom3)
        self.play(Transform(dom1, ci3),Transform(dom2,ci3),Transform(dom3, ci3), run_time = 3)
        self.wait()
        self.play(FadeOut(dom1, dom2, dom3, ci3))
        self.wait()


class annoy(Scene):
    def construct(self):        
        cck = Tex(r"curve that is closed and $C^k$", font_size = 44).shift(3*LEFT + 2*UP)
        csm = Tex(r"curve that is closed and smooth", font_size = 44).next_to(cck, DOWN).shift((0.85)*DOWN)
        cre = Tex(r"curve that is closed and regular", font_size = 44).next_to(csm, DOWN).shift((0.85)*DOWN)
        sr = Tex(r"curve that is regular and smooth", font_size = 44).next_to(cre, DOWN).shift((0.85)*DOWN)
        neq1 = Tex(r"$\neq$").shift(2*UP+0.8*RIGHT)
        xcen = neq1.get_left()
        neq2 = Tex(r"$\neq$").next_to(csm,RIGHT)
        neq2.shift((neq2.get_left() - xcen ) *LEFT )
        neq3 = Tex(r"$\neq$").next_to(cre,RIGHT)
        neq3.shift((neq3.get_left() - xcen ) *LEFT )
        neq4 = Tex(r"$\neq$").next_to(sr,RIGHT)
        neq4.shift((neq4.get_left() - xcen ) *LEFT )
        cck2 = Tex(r"$C^k$ closed curve", font_size = 44).shift(3.5*RIGHT + 2*UP)
        csm2 = Tex(r"closed smooth curve", font_size = 44).next_to(cck2, DOWN).shift((0.85)*DOWN)
        cre2 = Tex(r"closed regular curve", font_size = 44).next_to(csm2, DOWN).shift((0.85)*DOWN)
        sr2 = Tex(r"smooth regular curve", font_size = 44).next_to(cre2, DOWN).shift((0.85)*DOWN)
        self.play(FadeIn(cck, csm, cre, sr, neq1, neq2, neq3, neq4, cck2, csm2, cre2, sr2))
        self.wait()
        
        